#!/bin/bash
# This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
# This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).
#
# Prepare ROM for use in custom paths (not /data/data/io.twoyi/rootfs)
#
# The ROM's init binary has hardcoded paths that need to be patched:
#   - /data/data/io.twoyi/rootfs   (26 chars)
#   - /data/data/io.twoyi/loader64 (28 chars)
#   - /data/data/io.twoyi/loader32 (28 chars)
#
# This script patches these paths to work with custom directories.

set -e

# Original hardcoded paths in the init binary
ORIG_ROOTFS="/data/data/io.twoyi/rootfs"
ORIG_LOADER64="/data/data/io.twoyi/loader64"
ORIG_LOADER32="/data/data/io.twoyi/loader32"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS] <rootfs_directory>

Prepare ROM for use in a custom path. This script patches the init binary
to work with the specified rootfs directory instead of the hardcoded
/data/data/io.twoyi/rootfs path.

Arguments:
  rootfs_directory    The directory containing the extracted ROM rootfs

Options:
  -l, --loader PATH   Path to the loader64 file (default: parent_dir/loader64)
  -L, --loader32 PATH Path to the loader32 file (default: parent_dir/loader32)
  -n, --dry-run       Show what would be done without making changes
  -v, --verbose       Enable verbose output
  -h, --help          Show this help message

Examples:
  $0 /data/data/com.termux/files/home/rootfs_1
  $0 --loader /data/data/com.termux/files/home/loader64 /data/data/com.termux/files/home/rootfs_1

Notes:
  - The rootfs path must be <= 26 characters (same as original)
  - The loader paths must be <= 28 characters (same as original)
  - If your paths are longer, use symlinks to create shorter paths
  - The script modifies the init binary in-place (make a backup first!)

Path length limits:
  - Original rootfs:   /data/data/io.twoyi/rootfs   (26 chars)
  - Original loader64: /data/data/io.twoyi/loader64 (28 chars)
  - Original loader32: /data/data/io.twoyi/loader32 (28 chars)
EOF
}

# Validate path length
validate_path_length() {
    local path="$1"
    local max_len="$2"
    local name="$3"
    
    local len=${#path}
    if [ "$len" -gt "$max_len" ]; then
        log_error "$name path too long: $len characters (max: $max_len)"
        log_error "Path: $path"
        log_error "Consider using a symlink to create a shorter path."
        return 1
    fi
    return 0
}

# Pad a path with null bytes to match original length
pad_path() {
    local path="$1"
    local target_len="$2"
    local len=${#path}
    local padding=$((target_len - len))
    
    # Create the padded path (path + null bytes)
    printf "%s" "$path"
    for ((i=0; i<padding; i++)); do
        printf '\x00'
    done
}

# Patch binary file - replace one string with another (same length, padded with nulls)
patch_binary() {
    local file="$1"
    local old_path="$2"
    local new_path="$3"
    local target_len=${#old_path}
    
    if [ "$VERBOSE" = true ]; then
        log_info "Patching: $old_path -> $new_path (len: $target_len)"
    fi
    
    # Create padded version of new path
    local padded_new
    padded_new=$(pad_path "$new_path" "$target_len")
    
    if [ "$DRY_RUN" = true ]; then
        log_info "[DRY-RUN] Would replace '$old_path' with '$new_path' in $file"
        return 0
    fi
    
    # Use sed with binary-safe approach
    # Convert strings to hex for safe binary replacement
    local old_hex
    local new_hex
    
    old_hex=$(printf '%s' "$old_path" | xxd -p | tr -d '\n')
    new_hex=$(printf '%s' "$padded_new" | xxd -p | tr -d '\n')
    
    # Use xxd and sed to do binary replacement
    xxd -p "$file" | tr -d '\n' | sed "s/$old_hex/$new_hex/g" | xxd -r -p > "${file}.patched"
    
    if [ -f "${file}.patched" ]; then
        chmod --reference="$file" "${file}.patched"
        mv "${file}.patched" "$file"
        return 0
    else
        log_error "Failed to create patched file"
        return 1
    fi
}

# Main function
main() {
    local ROOTFS_DIR=""
    local LOADER64_PATH=""
    local LOADER32_PATH=""
    local DRY_RUN=false
    local VERBOSE=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -l|--loader)
                LOADER64_PATH="$2"
                shift 2
                ;;
            -L|--loader32)
                LOADER32_PATH="$2"
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                ROOTFS_DIR="$1"
                shift
                ;;
        esac
    done
    
    # Export variables for use in functions
    export DRY_RUN
    export VERBOSE
    
    # Validate rootfs directory
    if [ -z "$ROOTFS_DIR" ]; then
        log_error "No rootfs directory specified"
        show_usage
        exit 1
    fi
    
    # Remove trailing slash if present
    ROOTFS_DIR="${ROOTFS_DIR%/}"
    
    # Check if directory exists
    if [ ! -d "$ROOTFS_DIR" ]; then
        log_error "Rootfs directory does not exist: $ROOTFS_DIR"
        exit 1
    fi
    
    # Check for init binary
    local init_binary="$ROOTFS_DIR/init"
    if [ ! -f "$init_binary" ]; then
        log_error "init binary not found at: $init_binary"
        log_error "Make sure you've extracted the ROM correctly."
        exit 1
    fi
    
    # Set default loader paths if not specified
    local parent_dir
    parent_dir=$(dirname "$ROOTFS_DIR")
    
    if [ -z "$LOADER64_PATH" ]; then
        LOADER64_PATH="$parent_dir/loader64"
    fi
    
    if [ -z "$LOADER32_PATH" ]; then
        LOADER32_PATH="$parent_dir/loader32"
    fi
    
    log_info "ROM Preparation Script"
    log_info "======================"
    log_info "Rootfs directory: $ROOTFS_DIR (${#ROOTFS_DIR} chars)"
    log_info "Loader64 path: $LOADER64_PATH (${#LOADER64_PATH} chars)"
    log_info "Loader32 path: $LOADER32_PATH (${#LOADER32_PATH} chars)"
    echo ""
    
    # Validate path lengths
    local errors=0
    if ! validate_path_length "$ROOTFS_DIR" 26 "Rootfs"; then
        errors=$((errors + 1))
    fi
    if ! validate_path_length "$LOADER64_PATH" 28 "Loader64"; then
        errors=$((errors + 1))
    fi
    if ! validate_path_length "$LOADER32_PATH" 28 "Loader32"; then
        errors=$((errors + 1))
    fi
    
    if [ "$errors" -gt 0 ]; then
        log_error ""
        log_error "Path length validation failed. Please use shorter paths."
        log_error ""
        log_error "Tip: Create symlinks to shorten paths. For example:"
        log_error "  ln -s /data/data/com.termux/files/home/rootfs_1 /data/ty1"
        log_error "  $0 /data/ty1"
        exit 1
    fi
    
    # Check if init needs patching
    if ! strings "$init_binary" | grep -q "$ORIG_ROOTFS"; then
        log_warn "init binary doesn't contain original path: $ORIG_ROOTFS"
        log_warn "The binary may have already been patched or is from a different ROM version."
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 0
        fi
    fi
    
    # Backup init binary
    if [ "$DRY_RUN" = false ]; then
        log_info "Creating backup of init binary..."
        cp "$init_binary" "${init_binary}.backup"
    fi
    
    # Patch the init binary
    log_info "Patching init binary..."
    
    patch_binary "$init_binary" "$ORIG_ROOTFS" "$ROOTFS_DIR"
    patch_binary "$init_binary" "$ORIG_LOADER64" "$LOADER64_PATH"
    patch_binary "$init_binary" "$ORIG_LOADER32" "$LOADER32_PATH"
    
    # Ensure boot directories exist
    log_info "Creating required directories..."
    if [ "$DRY_RUN" = false ]; then
        mkdir -p "$ROOTFS_DIR/dev/input" 2>/dev/null || true
        mkdir -p "$ROOTFS_DIR/dev/socket" 2>/dev/null || true
        mkdir -p "$ROOTFS_DIR/dev/maps" 2>/dev/null || true
        mkdir -p "$ROOTFS_DIR/sdcard" 2>/dev/null || true
        mkdir -p "$parent_dir/socket" 2>/dev/null || true
    else
        log_info "[DRY-RUN] Would create: $ROOTFS_DIR/dev/input"
        log_info "[DRY-RUN] Would create: $ROOTFS_DIR/dev/socket"
        log_info "[DRY-RUN] Would create: $ROOTFS_DIR/dev/maps"
        log_info "[DRY-RUN] Would create: $ROOTFS_DIR/sdcard"
        log_info "[DRY-RUN] Would create: $parent_dir/socket"
    fi
    
    # Verify patching
    if [ "$DRY_RUN" = false ]; then
        log_info "Verifying patch..."
        if strings "$init_binary" | grep -q "$ROOTFS_DIR"; then
            log_info "✓ Rootfs path successfully patched"
        else
            log_warn "⚠ Could not verify rootfs path patch"
        fi
        
        if strings "$init_binary" | grep -q "$LOADER64_PATH"; then
            log_info "✓ Loader64 path successfully patched"
        else
            log_warn "⚠ Could not verify loader64 path patch"
        fi
    fi
    
    echo ""
    log_info "ROM preparation complete!"
    log_info ""
    log_info "Next steps:"
    log_info "1. Ensure the loader binary is available at: $LOADER64_PATH"
    log_info "2. If using threetwi/twoyi app, the loader is created automatically."
    log_info "3. If running standalone, set: export TYLOADER=$LOADER64_PATH"
    log_info "4. Start the container: cd $ROOTFS_DIR && ./init"
    log_info ""
    log_info "Backup of original init saved to: ${init_binary}.backup"
}

main "$@"
