// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! JNI bindings for the twoyi server
//!
//! This module provides JNI functions that can be called from Java/Kotlin Android code.

use jni::objects::{JClass, JString};
use jni::sys::{jint, jboolean, JNI_TRUE, JNI_FALSE};
use jni::JNIEnv;
use log::{info, error, Level};
use android_logger::Config;

use std::ffi::c_void;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

use crate::{ServerConfig, TwoyiServer};

/// Global server instance (lazy initialized)
static SERVER: once_cell::sync::Lazy<Mutex<Option<Arc<TwoyiServer>>>> = 
    once_cell::sync::Lazy::new(|| Mutex::new(None));

/// Initialize the server library (call once from Java)
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_nativeInit(
    _env: JNIEnv,
    _class: JClass,
) {
    android_logger::init_once(
        Config::default()
            .with_min_level(Level::Info)
            .with_tag("TWOYI_SERVER"),
    );
    info!("twoyi-server JNI library initialized");
}

/// Start the server with the given configuration
/// Returns true on success, false on failure
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_startServer(
    env: JNIEnv,
    _class: JClass,
    rootfs: JString,
    loader: JString,
    bind_address: JString,
    adb_address: JString,
    width: jint,
    height: jint,
    dpi: jint,
    profile: JString,
) -> jboolean {
    let rootfs_str: String = match env.get_string(rootfs) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get rootfs string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let loader_str: Option<String> = if loader.is_null() {
        None
    } else {
        match env.get_string(loader) {
            Ok(s) => Some(s.into()),
            Err(_) => None,
        }
    };

    let bind_str: String = match env.get_string(bind_address) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get bind_address string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let adb_str: String = match env.get_string(adb_address) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get adb_address string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let profile_str: String = match env.get_string(profile) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get profile string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let config = ServerConfig {
        rootfs: PathBuf::from(rootfs_str),
        loader: loader_str.map(PathBuf::from),
        bind_address: bind_str,
        adb_address: adb_str,
        width,
        height,
        dpi,
        profile: profile_str,
        ..Default::default()
    };

    let server = Arc::new(TwoyiServer::new(config));
    
    // Store server instance
    {
        let mut guard = SERVER.lock().unwrap();
        *guard = Some(server.clone());
    }

    // Start server in background thread
    match server.start_async() {
        Ok(_handle) => {
            info!("Server started successfully");
            JNI_TRUE
        }
        Err(e) => {
            error!("Failed to start server: {}", e);
            JNI_FALSE
        }
    }
}

/// Stop the server
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_stopServer(
    _env: JNIEnv,
    _class: JClass,
) {
    let mut guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        server.stop();
        info!("Server stopped");
    }
    *guard = None;
}

/// Check if server is running
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_isServerRunning(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    let guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        if server.is_running() {
            return JNI_TRUE;
        }
    }
    JNI_FALSE
}

/// Check if container is running
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_isContainerRunning(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    let guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        if server.is_container_running() {
            return JNI_TRUE;
        }
    }
    JNI_FALSE
}

/// Start only the input system (for use with existing renderer)
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_startInputSystem(
    env: JNIEnv,
    _class: JClass,
    rootfs: JString,
    width: jint,
    height: jint,
) {
    let rootfs_str: String = match env.get_string(rootfs) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get rootfs string: {:?}", e);
            return;
        }
    };

    info!("Starting input system: {}x{} in {}", width, height, rootfs_str);
    crate::input::start_input_system(width, height, &rootfs_str);
}

/// Handle touch event from Java
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_handleTouchEvent(
    _env: JNIEnv,
    _class: JClass,
    action: jint,
    pointer_id: jint,
    x: jint,
    y: jint,
    pressure: jint,
) {
    crate::input::handle_touch_event(action, pointer_id, x as f32, y as f32, pressure as f32);
}

/// Send key event from Java
#[no_mangle]
pub extern "C" fn Java_io_twoyi_NativeServer_sendKeyCode(
    _env: JNIEnv,
    _class: JClass,
    keycode: jint,
) {
    crate::input::send_key_code(keycode);
}

/// JNI_OnLoad - called when the library is loaded
#[no_mangle]
#[allow(non_snake_case)]
pub extern "C" fn JNI_OnLoad(
    vm: jni::JavaVM,
    _reserved: *mut c_void,
) -> jint {
    let env = match vm.get_env() {
        Ok(e) => e,
        Err(_) => return jni::sys::JNI_ERR,
    };

    android_logger::init_once(
        Config::default()
            .with_min_level(Level::Info)
            .with_tag("TWOYI_SERVER"),
    );

    info!("twoyi-server JNI library loaded");

    let version = env.get_version().unwrap();
    version.into()
}
