// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! ROM binary patching module
//!
//! The ROM has hardcoded paths in multiple binary files that need to be patched for custom rootfs locations.
//!
//! Files containing hardcoded paths:
//!   - init, sbin/charger, system/lib64/libc.so, system/bin/adbd, system/bin/linker64,
//!   - system/bin/mdnsd, system/xbin/su, system/lib64/libOpenglRender.so, system/lib64/libui.so,
//!   - system/vendor/lib64/egl/libEGL_emulation.so, system/vendor/lib64/libOpenglSystemCommon.so
//!
//! Hardcoded paths that need patching:
//!   - /data/data/io.twoyi/rootfs   (26 bytes) - base path
//!   - /data/data/io.twoyi/loader64 (28 bytes) - loader path
//!   - /data/data/io.twoyi/loader32 (28 bytes) - loader path
//!   - /data/data/io.twoyi/rootfs/dev/socket/property_service (54 bytes) - derived
//!   - /data/data/io.twoyi/rootfs/opengles (35 bytes) - derived
//!   - /data/data/io.twoyi/rootfs/opengles2 (36 bytes) - derived
//!   - /data/data/io.twoyi/rootfs/opengles3 (36 bytes) - derived
//!   - /data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv1_CM_emulation.so (69 bytes) - derived
//!   - /data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv2_emulation.so (66 bytes) - derived

use log::{info, warn, debug};
use std::fs;
use std::path::PathBuf;

/// Original hardcoded paths in the ROM binaries
pub const ORIG_ROOTFS: &str = "/data/data/io.twoyi/rootfs";
pub const ORIG_LOADER64: &str = "/data/data/io.twoyi/loader64";
pub const ORIG_LOADER32: &str = "/data/data/io.twoyi/loader32";

/// Derived paths (these start with ORIG_ROOTFS)
pub const ORIG_PROPERTY_SERVICE: &str = "/data/data/io.twoyi/rootfs/dev/socket/property_service";
pub const ORIG_OPENGLES: &str = "/data/data/io.twoyi/rootfs/opengles";
pub const ORIG_OPENGLES2: &str = "/data/data/io.twoyi/rootfs/opengles2";
pub const ORIG_OPENGLES3: &str = "/data/data/io.twoyi/rootfs/opengles3";
pub const ORIG_GLES1_EMU: &str = "/data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv1_CM_emulation.so";
pub const ORIG_GLES2_EMU: &str = "/data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv2_emulation.so";

/// Maximum path lengths (must match original paths)
pub const MAX_ROOTFS_LEN: usize = 26;   // Length of ORIG_ROOTFS
pub const MAX_LOADER64_LEN: usize = 28; // Length of ORIG_LOADER64
pub const MAX_LOADER32_LEN: usize = 28; // Length of ORIG_LOADER32

/// Files that need patching (relative to rootfs directory)
pub const FILES_TO_PATCH: &[&str] = &[
    "init",
    "sbin/charger",
    "system/lib64/libc.so",
    "system/lib64/libOpenglRender.so",
    "system/lib64/libui.so",
    "system/bin/adbd",
    "system/bin/linker64",
    "system/bin/mdnsd",
    "system/vendor/lib64/egl/libEGL_emulation.so",
    "system/vendor/lib64/libOpenglSystemCommon.so",
    "system/xbin/su",
];

/// Result of patching operation
#[derive(Debug)]
pub enum PatchResult {
    /// Patching succeeded
    Success,
    /// Already patched for the target path
    AlreadyPatched,
    /// Path too long (with recommendation)
    PathTooLong(String),
    /// File not found
    FileNotFound(String),
    /// IO error
    IoError(String),
    /// Using default path, no patching needed
    DefaultPath,
}

/// Validate that paths are within allowed length limits
pub fn validate_path_lengths(rootfs_path: &str, loader64_path: &str, loader32_path: &str) -> Result<(), String> {
    let mut errors = Vec::new();

    if rootfs_path.len() > MAX_ROOTFS_LEN {
        errors.push(format!(
            "Rootfs path too long: {} chars (max: {}). Path: {}",
            rootfs_path.len(), MAX_ROOTFS_LEN, rootfs_path
        ));
    }
    if loader64_path.len() > MAX_LOADER64_LEN {
        errors.push(format!(
            "Loader64 path too long: {} chars (max: {}). Path: {}",
            loader64_path.len(), MAX_LOADER64_LEN, loader64_path
        ));
    }
    if loader32_path.len() > MAX_LOADER32_LEN {
        errors.push(format!(
            "Loader32 path too long: {} chars (max: {}). Path: {}",
            loader32_path.len(), MAX_LOADER32_LEN, loader32_path
        ));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors.join("\n"))
    }
}

/// Check if the rootfs path is the default path that doesn't need patching
pub fn is_default_path(rootfs_path: &str) -> bool {
    rootfs_path == ORIG_ROOTFS
}

/// Check if the init binary contains the original hardcoded path
fn contains_original_path(content: &[u8]) -> bool {
    let needle = ORIG_ROOTFS.as_bytes();
    content.windows(needle.len()).any(|window| window == needle)
}

/// Check if the init binary already contains the target path
fn contains_target_path(content: &[u8], target_path: &str) -> bool {
    let needle = target_path.as_bytes();
    content.windows(needle.len()).any(|window| window == needle)
}

/// Get the backup path for an init binary
fn get_backup_path(init_path: &PathBuf) -> PathBuf {
    let mut backup = init_path.clone();
    let file_name = backup.file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("init");
    backup.set_file_name(format!("{}.backup", file_name));
    backup
}

/// Replace all occurrences of old_str with new_str (padded with null bytes) in content
fn replace_bytes(content: &mut Vec<u8>, old_str: &str, new_str: &str, target_len: usize) -> bool {
    let old_bytes = old_str.as_bytes();
    let mut new_bytes = vec![0u8; target_len];
    let new_str_bytes = new_str.as_bytes();
    new_bytes[..new_str_bytes.len()].copy_from_slice(new_str_bytes);
    // Rest is already zeros (null padding)

    let mut modified = false;
    let mut i = 0;
    
    while i <= content.len().saturating_sub(old_bytes.len()) {
        if &content[i..i + old_bytes.len()] == old_bytes {
            // Found a match, replace it
            content[i..i + target_len].copy_from_slice(&new_bytes);
            modified = true;
            debug!("Replaced '{}' at offset {}", old_str, i);
            i += target_len;
        } else {
            i += 1;
        }
    }

    modified
}

/// Patch the init binary to use custom paths
///
/// # Arguments
/// * `init_path` - Path to the init binary
/// * `rootfs_path` - The new rootfs path
/// * `loader64_path` - The new loader64 path (optional, derived from rootfs if None)
/// * `loader32_path` - The new loader32 path (optional, derived from rootfs if None)
///
/// # Returns
/// * `PatchResult` indicating success or failure
pub fn patch_init_binary(
    init_path: &PathBuf,
    rootfs_path: &str,
    loader64_path: Option<&str>,
    loader32_path: Option<&str>,
) -> PatchResult {
    // Check if using default path
    if is_default_path(rootfs_path) {
        info!("Using default rootfs path, no patching needed");
        return PatchResult::DefaultPath;
    }

    // Derive loader paths if not provided
    let rootfs_dir = PathBuf::from(rootfs_path);
    let parent_dir = match rootfs_dir.parent() {
        Some(p) => p,
        None => {
            return PatchResult::IoError("Cannot derive loader paths: rootfs path has no parent".to_string());
        }
    };

    let loader64 = loader64_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader64").to_string_lossy().to_string());
    let loader32 = loader32_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader32").to_string_lossy().to_string());

    // Validate path lengths
    if let Err(e) = validate_path_lengths(rootfs_path, &loader64, &loader32) {
        let recommendation = format!(
            "{}\n\nTip: Create symlinks to shorten paths. For example:\n  ln -s '{}' /data/ty1\n  Then use /data/ty1 as the rootfs path.",
            e, rootfs_path
        );
        return PatchResult::PathTooLong(recommendation);
    }

    // Check if init file exists
    if !init_path.exists() {
        return PatchResult::FileNotFound(format!("Init binary not found: {:?}", init_path));
    }

    // Read the init binary
    let mut content = match fs::read(init_path) {
        Ok(c) => c,
        Err(e) => {
            return PatchResult::IoError(format!("Failed to read init binary: {}", e));
        }
    };

    info!("Read init binary: {} bytes from {:?}", content.len(), init_path);

    // Check if already patched for target path
    if contains_target_path(&content, rootfs_path) && !contains_original_path(&content) {
        info!("Init binary already patched for path: {}", rootfs_path);
        return PatchResult::AlreadyPatched;
    }

    // Check if it contains the original path
    if !contains_original_path(&content) {
        warn!("Init binary doesn't contain original path '{}' - may be from a different ROM version or already patched for a different path", ORIG_ROOTFS);
        // Continue anyway, as it might have been patched before
    }

    // Create backup before patching
    let backup_path = get_backup_path(init_path);
    if !backup_path.exists() {
        match fs::copy(init_path, &backup_path) {
            Ok(_) => info!("Created backup: {:?}", backup_path),
            Err(e) => warn!("Failed to create backup: {}", e),
        }
    }

    // Perform patching
    let mut modified = false;

    if replace_bytes(&mut content, ORIG_ROOTFS, rootfs_path, MAX_ROOTFS_LEN) {
        info!("Patched rootfs path: {} -> {}", ORIG_ROOTFS, rootfs_path);
        modified = true;
    } else {
        debug!("Rootfs path not found or already patched");
    }

    if replace_bytes(&mut content, ORIG_LOADER64, &loader64, MAX_LOADER64_LEN) {
        info!("Patched loader64 path: {} -> {}", ORIG_LOADER64, loader64);
        modified = true;
    } else {
        debug!("Loader64 path not found or already patched");
    }

    if replace_bytes(&mut content, ORIG_LOADER32, &loader32, MAX_LOADER32_LEN) {
        info!("Patched loader32 path: {} -> {}", ORIG_LOADER32, loader32);
        modified = true;
    } else {
        debug!("Loader32 path not found or already patched");
    }

    if modified {
        // Write the patched binary
        match fs::write(init_path, &content) {
            Ok(_) => {
                info!("Wrote patched init binary to {:?}", init_path);
                
                // Ensure it's executable
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    if let Err(e) = fs::set_permissions(init_path, fs::Permissions::from_mode(0o755)) {
                        warn!("Failed to set executable permission: {}", e);
                    }
                }
                
                PatchResult::Success
            }
            Err(e) => PatchResult::IoError(format!("Failed to write patched init binary: {}", e)),
        }
    } else {
        info!("No modifications made to init binary");
        PatchResult::AlreadyPatched
    }
}

/// Patch a single binary file with all known hardcoded paths
fn patch_single_file(
    file_path: &PathBuf,
    rootfs_path: &str,
    loader64_path: &str,
    loader32_path: &str,
) -> Result<bool, String> {
    if !file_path.exists() {
        debug!("File not found, skipping: {:?}", file_path);
        return Ok(false);
    }

    let mut content = fs::read(file_path)
        .map_err(|e| format!("Failed to read {:?}: {}", file_path, e))?;

    let original_len = content.len();
    let mut modified = false;

    // Patch base paths (these have fixed replacement lengths)
    if replace_bytes(&mut content, ORIG_ROOTFS, rootfs_path, MAX_ROOTFS_LEN) {
        modified = true;
    }
    if replace_bytes(&mut content, ORIG_LOADER64, loader64_path, MAX_LOADER64_LEN) {
        modified = true;
    }
    if replace_bytes(&mut content, ORIG_LOADER32, loader32_path, MAX_LOADER32_LEN) {
        modified = true;
    }

    // Patch derived paths (paths that start with rootfs path)
    // These need to be replaced with the new rootfs path prefix
    let derived_paths = [
        (ORIG_PROPERTY_SERVICE, format!("{}/dev/socket/property_service", rootfs_path)),
        (ORIG_OPENGLES, format!("{}/opengles", rootfs_path)),
        (ORIG_OPENGLES2, format!("{}/opengles2", rootfs_path)),
        (ORIG_OPENGLES3, format!("{}/opengles3", rootfs_path)),
        (ORIG_GLES1_EMU, format!("{}/vendor/lib64/egl/libGLESv1_CM_emulation.so", rootfs_path)),
        (ORIG_GLES2_EMU, format!("{}/vendor/lib64/egl/libGLESv2_emulation.so", rootfs_path)),
    ];

    for (orig_path, new_path) in &derived_paths {
        let orig_len = orig_path.len();
        if new_path.len() <= orig_len {
            if replace_bytes(&mut content, orig_path, new_path, orig_len) {
                modified = true;
            }
        } else {
            debug!("Derived path {} is too long ({} > {}), skipping", new_path, new_path.len(), orig_len);
        }
    }

    if modified {
        // Verify content length hasn't changed
        if content.len() != original_len {
            return Err(format!("Content length changed during patching: {} -> {}", original_len, content.len()));
        }

        // Create backup
        let backup_path = get_backup_path(file_path);
        if !backup_path.exists() {
            if let Err(e) = fs::copy(file_path, &backup_path) {
                warn!("Failed to create backup for {:?}: {}", file_path, e);
            }
        }

        fs::write(file_path, &content)
            .map_err(|e| format!("Failed to write {:?}: {}", file_path, e))?;

        // Preserve executable permission
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            if let Ok(metadata) = fs::metadata(file_path) {
                let mode = metadata.permissions().mode();
                if mode & 0o111 != 0 {
                    let _ = fs::set_permissions(file_path, fs::Permissions::from_mode(mode));
                }
            }
        }

        debug!("Patched file: {:?}", file_path);
    }

    Ok(modified)
}

/// Patch all ROM files that contain hardcoded paths
///
/// This function patches all binary files in the ROM that contain hardcoded
/// /data/data/io.twoyi paths, replacing them with the actual rootfs path.
///
/// # Arguments
/// * `rootfs_dir` - Path to the rootfs directory
/// * `loader64_path` - The new loader64 path (optional, derived from rootfs if None)
/// * `loader32_path` - The new loader32 path (optional, derived from rootfs if None)
///
/// # Returns
/// * `PatchResult` indicating success or failure
pub fn patch_all_rom_files(
    rootfs_dir: &PathBuf,
    loader64_path: Option<&str>,
    loader32_path: Option<&str>,
) -> PatchResult {
    let rootfs_path = rootfs_dir.to_string_lossy().to_string();

    // Check if using default path
    if is_default_path(&rootfs_path) {
        info!("Using default rootfs path, no patching needed");
        return PatchResult::DefaultPath;
    }

    // Derive loader paths if not provided
    let parent_dir = match rootfs_dir.parent() {
        Some(p) => p,
        None => {
            return PatchResult::IoError("Cannot derive loader paths: rootfs path has no parent".to_string());
        }
    };

    let loader64 = loader64_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader64").to_string_lossy().to_string());
    let loader32 = loader32_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader32").to_string_lossy().to_string());

    // Validate path lengths
    if let Err(e) = validate_path_lengths(&rootfs_path, &loader64, &loader32) {
        let recommendation = format!(
            "{}\n\nTip: Create symlinks to shorten paths. For example:\n  ln -s '{}' /data/ty1\n  Then use /data/ty1 as the rootfs path.",
            e, rootfs_path
        );
        return PatchResult::PathTooLong(recommendation);
    }

    info!("Patching ROM files in {:?}", rootfs_dir);
    info!("New rootfs path: {}", rootfs_path);
    info!("New loader64 path: {}", loader64);
    info!("New loader32 path: {}", loader32);

    let mut total_patched = 0;
    let mut total_errors = 0;

    for relative_path in FILES_TO_PATCH {
        let file_path = rootfs_dir.join(relative_path);
        match patch_single_file(&file_path, &rootfs_path, &loader64, &loader32) {
            Ok(true) => {
                info!("Patched: {}", relative_path);
                total_patched += 1;
            }
            Ok(false) => {
                debug!("Skipped (not found or no changes): {}", relative_path);
            }
            Err(e) => {
                warn!("Error patching {}: {}", relative_path, e);
                total_errors += 1;
            }
        }
    }

    if total_patched > 0 {
        info!("ROM patching complete: {} files patched, {} errors", total_patched, total_errors);
        PatchResult::Success
    } else if total_errors > 0 {
        PatchResult::IoError(format!("All {} patch attempts failed", total_errors))
    } else {
        info!("ROM already patched or no files found");
        PatchResult::AlreadyPatched
    }
}

/// Restore the init binary from backup
pub fn restore_from_backup(init_path: &PathBuf) -> Result<(), String> {
    let backup_path = PathBuf::from(format!("{}.backup", init_path.to_string_lossy()));
    
    if !backup_path.exists() {
        return Err(format!("Backup file does not exist: {:?}", backup_path));
    }

    fs::copy(&backup_path, init_path)
        .map_err(|e| format!("Failed to restore from backup: {}", e))?;
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Err(e) = fs::set_permissions(init_path, fs::Permissions::from_mode(0o755)) {
            warn!("Failed to set executable permission: {}", e);
        }
    }
    
    info!("Restored init binary from backup: {:?}", backup_path);
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_default_path() {
        assert!(is_default_path("/data/data/io.twoyi/rootfs"));
        assert!(!is_default_path("/data/ty1"));
        assert!(!is_default_path("/tmp/rootfs"));
    }

    #[test]
    fn test_validate_path_lengths() {
        // Valid paths
        assert!(validate_path_lengths(
            "/data/ty1",
            "/data/ty1/loader64",
            "/data/ty1/loader32"
        ).is_ok());

        // Exactly at limit
        assert!(validate_path_lengths(
            "/data/data/io.twoyi/rootfs", // 26 chars
            "/data/data/io.twoyi/loader64", // 28 chars
            "/data/data/io.twoyi/loader32", // 28 chars
        ).is_ok());

        // Too long rootfs
        let long_path = "/data/data/very/long/path/to/rootfs";
        assert!(validate_path_lengths(long_path, "/data/loader64", "/data/loader32").is_err());
    }

    #[test]
    fn test_replace_bytes() {
        let mut content = b"test/data/data/io.twoyi/rootfs/more".to_vec();
        let old_str = "/data/data/io.twoyi/rootfs";
        let new_str = "/data/ty1";
        
        let modified = replace_bytes(&mut content, old_str, new_str, 26);
        assert!(modified);
        
        // Check that the replacement was made with null padding
        let expected_start = b"test/data/ty1";
        assert_eq!(&content[..expected_start.len()], expected_start.as_slice());
    }

    #[test]
    fn test_contains_original_path() {
        let content_with_path = b"something/data/data/io.twoyi/rootfssomething";
        let content_without_path = b"something/data/ty1something";
        
        assert!(contains_original_path(content_with_path));
        assert!(!contains_original_path(content_without_path));
    }
}
