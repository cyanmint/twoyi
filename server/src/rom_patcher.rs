// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! ROM init binary patching module
//!
//! The ROM's init binary has hardcoded paths that need to be patched for custom rootfs locations:
//!   - /data/data/io.twoyi/rootfs   (26 bytes)
//!   - /data/data/io.twoyi/loader64 (28 bytes)
//!   - /data/data/io.twoyi/loader32 (28 bytes)
//!
//! This module provides functions to automatically patch these paths when the server starts,
//! using the actual rootfs and loader paths provided via command line arguments.

use log::{info, warn, debug};
use std::fs;
use std::path::PathBuf;

/// Original hardcoded paths in the init binary
pub const ORIG_ROOTFS: &str = "/data/data/io.twoyi/rootfs";
pub const ORIG_LOADER64: &str = "/data/data/io.twoyi/loader64";
pub const ORIG_LOADER32: &str = "/data/data/io.twoyi/loader32";

/// Maximum path lengths (must match original paths)
pub const MAX_ROOTFS_LEN: usize = 26;   // Length of ORIG_ROOTFS
pub const MAX_LOADER64_LEN: usize = 28; // Length of ORIG_LOADER64
pub const MAX_LOADER32_LEN: usize = 28; // Length of ORIG_LOADER32

/// Result of patching operation
#[derive(Debug)]
pub enum PatchResult {
    /// Patching succeeded
    Success,
    /// Already patched for the target path
    AlreadyPatched,
    /// Path too long (with recommendation)
    PathTooLong(String),
    /// File not found
    FileNotFound(String),
    /// IO error
    IoError(String),
    /// Using default path, no patching needed
    DefaultPath,
}

/// Validate that paths are within allowed length limits
pub fn validate_path_lengths(rootfs_path: &str, loader64_path: &str, loader32_path: &str) -> Result<(), String> {
    let mut errors = Vec::new();

    if rootfs_path.len() > MAX_ROOTFS_LEN {
        errors.push(format!(
            "Rootfs path too long: {} chars (max: {}). Path: {}",
            rootfs_path.len(), MAX_ROOTFS_LEN, rootfs_path
        ));
    }
    if loader64_path.len() > MAX_LOADER64_LEN {
        errors.push(format!(
            "Loader64 path too long: {} chars (max: {}). Path: {}",
            loader64_path.len(), MAX_LOADER64_LEN, loader64_path
        ));
    }
    if loader32_path.len() > MAX_LOADER32_LEN {
        errors.push(format!(
            "Loader32 path too long: {} chars (max: {}). Path: {}",
            loader32_path.len(), MAX_LOADER32_LEN, loader32_path
        ));
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors.join("\n"))
    }
}

/// Check if the rootfs path is the default path that doesn't need patching
pub fn is_default_path(rootfs_path: &str) -> bool {
    rootfs_path == ORIG_ROOTFS
}

/// Check if the init binary contains the original hardcoded path
fn contains_original_path(content: &[u8]) -> bool {
    let needle = ORIG_ROOTFS.as_bytes();
    content.windows(needle.len()).any(|window| window == needle)
}

/// Check if the init binary already contains the target path
fn contains_target_path(content: &[u8], target_path: &str) -> bool {
    let needle = target_path.as_bytes();
    content.windows(needle.len()).any(|window| window == needle)
}

/// Replace all occurrences of old_str with new_str (padded with null bytes) in content
fn replace_bytes(content: &mut Vec<u8>, old_str: &str, new_str: &str, target_len: usize) -> bool {
    let old_bytes = old_str.as_bytes();
    let mut new_bytes = vec![0u8; target_len];
    let new_str_bytes = new_str.as_bytes();
    new_bytes[..new_str_bytes.len()].copy_from_slice(new_str_bytes);
    // Rest is already zeros (null padding)

    let mut modified = false;
    let mut i = 0;
    
    while i <= content.len().saturating_sub(old_bytes.len()) {
        if &content[i..i + old_bytes.len()] == old_bytes {
            // Found a match, replace it
            content[i..i + target_len].copy_from_slice(&new_bytes);
            modified = true;
            debug!("Replaced '{}' at offset {}", old_str, i);
            i += target_len;
        } else {
            i += 1;
        }
    }

    modified
}

/// Patch the init binary to use custom paths
///
/// # Arguments
/// * `init_path` - Path to the init binary
/// * `rootfs_path` - The new rootfs path
/// * `loader64_path` - The new loader64 path (optional, derived from rootfs if None)
/// * `loader32_path` - The new loader32 path (optional, derived from rootfs if None)
///
/// # Returns
/// * `PatchResult` indicating success or failure
pub fn patch_init_binary(
    init_path: &PathBuf,
    rootfs_path: &str,
    loader64_path: Option<&str>,
    loader32_path: Option<&str>,
) -> PatchResult {
    // Check if using default path
    if is_default_path(rootfs_path) {
        info!("Using default rootfs path, no patching needed");
        return PatchResult::DefaultPath;
    }

    // Derive loader paths if not provided
    let rootfs_dir = PathBuf::from(rootfs_path);
    let parent_dir = match rootfs_dir.parent() {
        Some(p) => p,
        None => {
            return PatchResult::IoError("Cannot derive loader paths: rootfs path has no parent".to_string());
        }
    };

    let loader64 = loader64_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader64").to_string_lossy().to_string());
    let loader32 = loader32_path
        .map(String::from)
        .unwrap_or_else(|| parent_dir.join("loader32").to_string_lossy().to_string());

    // Validate path lengths
    if let Err(e) = validate_path_lengths(rootfs_path, &loader64, &loader32) {
        let recommendation = format!(
            "{}\n\nTip: Create symlinks to shorten paths. For example:\n  ln -s '{}' /data/ty1\n  Then use /data/ty1 as the rootfs path.",
            e, rootfs_path
        );
        return PatchResult::PathTooLong(recommendation);
    }

    // Check if init file exists
    if !init_path.exists() {
        return PatchResult::FileNotFound(format!("Init binary not found: {:?}", init_path));
    }

    // Read the init binary
    let mut content = match fs::read(init_path) {
        Ok(c) => c,
        Err(e) => {
            return PatchResult::IoError(format!("Failed to read init binary: {}", e));
        }
    };

    info!("Read init binary: {} bytes from {:?}", content.len(), init_path);

    // Check if already patched for target path
    if contains_target_path(&content, rootfs_path) && !contains_original_path(&content) {
        info!("Init binary already patched for path: {}", rootfs_path);
        return PatchResult::AlreadyPatched;
    }

    // Check if it contains the original path
    if !contains_original_path(&content) {
        warn!("Init binary doesn't contain original path '{}' - may be from a different ROM version or already patched for a different path", ORIG_ROOTFS);
        // Continue anyway, as it might have been patched before
    }

    // Create backup before patching
    let backup_path = PathBuf::from(format!("{}.backup", init_path.to_string_lossy()));
    if !backup_path.exists() {
        match fs::copy(init_path, &backup_path) {
            Ok(_) => info!("Created backup: {:?}", backup_path),
            Err(e) => warn!("Failed to create backup: {}", e),
        }
    }

    // Perform patching
    let mut modified = false;

    if replace_bytes(&mut content, ORIG_ROOTFS, rootfs_path, MAX_ROOTFS_LEN) {
        info!("Patched rootfs path: {} -> {}", ORIG_ROOTFS, rootfs_path);
        modified = true;
    } else {
        debug!("Rootfs path not found or already patched");
    }

    if replace_bytes(&mut content, ORIG_LOADER64, &loader64, MAX_LOADER64_LEN) {
        info!("Patched loader64 path: {} -> {}", ORIG_LOADER64, loader64);
        modified = true;
    } else {
        debug!("Loader64 path not found or already patched");
    }

    if replace_bytes(&mut content, ORIG_LOADER32, &loader32, MAX_LOADER32_LEN) {
        info!("Patched loader32 path: {} -> {}", ORIG_LOADER32, loader32);
        modified = true;
    } else {
        debug!("Loader32 path not found or already patched");
    }

    if modified {
        // Write the patched binary
        match fs::write(init_path, &content) {
            Ok(_) => {
                info!("Wrote patched init binary to {:?}", init_path);
                
                // Ensure it's executable
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    if let Err(e) = fs::set_permissions(init_path, fs::Permissions::from_mode(0o755)) {
                        warn!("Failed to set executable permission: {}", e);
                    }
                }
                
                PatchResult::Success
            }
            Err(e) => PatchResult::IoError(format!("Failed to write patched init binary: {}", e)),
        }
    } else {
        info!("No modifications made to init binary");
        PatchResult::AlreadyPatched
    }
}

/// Restore the init binary from backup
pub fn restore_from_backup(init_path: &PathBuf) -> Result<(), String> {
    let backup_path = PathBuf::from(format!("{}.backup", init_path.to_string_lossy()));
    
    if !backup_path.exists() {
        return Err(format!("Backup file does not exist: {:?}", backup_path));
    }

    fs::copy(&backup_path, init_path)
        .map_err(|e| format!("Failed to restore from backup: {}", e))?;
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Err(e) = fs::set_permissions(init_path, fs::Permissions::from_mode(0o755)) {
            warn!("Failed to set executable permission: {}", e);
        }
    }
    
    info!("Restored init binary from backup: {:?}", backup_path);
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_default_path() {
        assert!(is_default_path("/data/data/io.twoyi/rootfs"));
        assert!(!is_default_path("/data/ty1"));
        assert!(!is_default_path("/tmp/rootfs"));
    }

    #[test]
    fn test_validate_path_lengths() {
        // Valid paths
        assert!(validate_path_lengths(
            "/data/ty1",
            "/data/ty1/loader64",
            "/data/ty1/loader32"
        ).is_ok());

        // Exactly at limit
        assert!(validate_path_lengths(
            "/data/data/io.twoyi/rootfs", // 26 chars
            "/data/data/io.twoyi/loader64", // 28 chars
            "/data/data/io.twoyi/loader32", // 28 chars
        ).is_ok());

        // Too long rootfs
        let long_path = "/data/data/very/long/path/to/rootfs";
        assert!(validate_path_lengths(long_path, "/data/loader64", "/data/loader32").is_err());
    }

    #[test]
    fn test_replace_bytes() {
        let mut content = b"test/data/data/io.twoyi/rootfs/more".to_vec();
        let old_str = "/data/data/io.twoyi/rootfs";
        let new_str = "/data/ty1";
        
        let modified = replace_bytes(&mut content, old_str, new_str, 26);
        assert!(modified);
        
        // Check that the replacement was made with null padding
        let expected_start = b"test/data/ty1";
        assert_eq!(&content[..expected_start.len()], expected_start.as_slice());
    }

    #[test]
    fn test_contains_original_path() {
        let content_with_path = b"something/data/data/io.twoyi/rootfssomething";
        let content_without_path = b"something/data/ty1something";
        
        assert!(contains_original_path(content_with_path));
        assert!(!contains_original_path(content_without_path));
    }
}
