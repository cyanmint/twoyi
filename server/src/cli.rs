// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! CLI module for libtwoyi.so
//!
//! This module provides command-line argument parsing when the library is executed directly.
//! Usage: ./libtwoyi.so -r $(realpath rootfs) [options]

use std::ffi::CStr;
use std::path::PathBuf;
use log::{info, error};

use crate::{ServerConfig, TwoyiServer};

/// Default ADB address for scrcpy connections
const DEFAULT_ADB_ADDRESS: &str = "0.0.0.0:5556";
const DEFAULT_BIND_ADDRESS: &str = "0.0.0.0:8765";

/// Print usage information
fn print_usage(program_name: &str) {
    eprintln!("libtwoyi - twoyi container server");
    eprintln!();
    eprintln!("This library can be run as a standalone executable or loaded as a JNI library.");
    eprintln!();
    eprintln!("USAGE:");
    eprintln!("    {} -r <ROOTFS> [OPTIONS]", program_name);
    eprintln!();
    eprintln!("OPTIONS:");
    eprintln!("    -r, --rootfs <PATH>      Path to the rootfs directory (required)");
    eprintln!("    -l, --loader <PATH>      Path to the loader library (libloader.so)");
    eprintln!("    -b, --bind <ADDR>        Address for control connections (default: {})", DEFAULT_BIND_ADDRESS);
    eprintln!("    -a, --adb <ADDR>         ADB address for scrcpy (default: {})", DEFAULT_ADB_ADDRESS);
    eprintln!("    -W, --width <PIXELS>     Screen width (default: 1080)");
    eprintln!("    -H, --height <PIXELS>    Screen height (default: 1920)");
    eprintln!("    -d, --dpi <DPI>          Screen DPI (default: 320)");
    eprintln!("    -v, --verbose <LEVEL>    Verbosity: none, v (default), vv");
    eprintln!("    -s, --setup              Setup mode (don't start container)");
    eprintln!("    -P, --patch              Patch ROM binaries for custom paths");
    eprintln!("    -p, --profile <NAME>     Profile name (default: default)");
    eprintln!("    -h, --help               Print this help message");
    eprintln!();
    eprintln!("EXAMPLES:");
    eprintln!("    {} -r /data/data/io.twoyi/rootfs", program_name);
    eprintln!("    {} -r $(realpath rootfs) -W 720 -H 1280", program_name);
}

/// Parse command line arguments and run the server
pub fn run_cli(argc: libc::c_int, argv: *const *const libc::c_char) -> libc::c_int {
    // Convert C arguments to Rust strings
    let args: Vec<String> = (0..argc as usize)
        .filter_map(|i| {
            let arg_ptr = unsafe { *argv.add(i) };
            if arg_ptr.is_null() {
                None
            } else {
                unsafe { CStr::from_ptr(arg_ptr) }
                    .to_str()
                    .ok()
                    .map(String::from)
            }
        })
        .collect();

    if args.is_empty() {
        eprintln!("Error: No arguments provided");
        return 1;
    }

    let program_name = &args[0];

    // Parse arguments manually (simple implementation without external dependencies)
    let mut rootfs: Option<PathBuf> = None;
    let mut loader: Option<PathBuf> = None;
    let mut bind_address = DEFAULT_BIND_ADDRESS.to_string();
    let mut adb_address = DEFAULT_ADB_ADDRESS.to_string();
    let mut width: i32 = 1080;
    let mut height: i32 = 1920;
    let mut dpi: i32 = 320;
    let mut verbose = "v".to_string();
    let mut setup_mode = false;
    let mut patch_rom = false;
    let mut profile = "default".to_string();

    let mut i = 1;
    while i < args.len() {
        let arg = &args[i];
        match arg.as_str() {
            "-h" | "--help" => {
                print_usage(program_name);
                return 0;
            }
            "-r" | "--rootfs" => {
                i += 1;
                if i < args.len() {
                    rootfs = Some(PathBuf::from(&args[i]));
                } else {
                    eprintln!("Error: -r/--rootfs requires a path argument");
                    return 1;
                }
            }
            "-l" | "--loader" => {
                i += 1;
                if i < args.len() {
                    loader = Some(PathBuf::from(&args[i]));
                } else {
                    eprintln!("Error: -l/--loader requires a path argument");
                    return 1;
                }
            }
            "-b" | "--bind" => {
                i += 1;
                if i < args.len() {
                    bind_address = args[i].clone();
                } else {
                    eprintln!("Error: -b/--bind requires an address argument");
                    return 1;
                }
            }
            "-a" | "--adb" => {
                i += 1;
                if i < args.len() {
                    adb_address = args[i].clone();
                } else {
                    eprintln!("Error: -a/--adb requires an address argument");
                    return 1;
                }
            }
            "-W" | "--width" => {
                i += 1;
                if i < args.len() {
                    width = args[i].parse().unwrap_or_else(|_| {
                        eprintln!("Warning: Invalid width, using default");
                        1080
                    });
                } else {
                    eprintln!("Error: -W/--width requires a number argument");
                    return 1;
                }
            }
            "-H" | "--height" => {
                i += 1;
                if i < args.len() {
                    height = args[i].parse().unwrap_or_else(|_| {
                        eprintln!("Warning: Invalid height, using default");
                        1920
                    });
                } else {
                    eprintln!("Error: -H/--height requires a number argument");
                    return 1;
                }
            }
            "-d" | "--dpi" => {
                i += 1;
                if i < args.len() {
                    dpi = args[i].parse().unwrap_or_else(|_| {
                        eprintln!("Warning: Invalid DPI, using default");
                        320
                    });
                } else {
                    eprintln!("Error: -d/--dpi requires a number argument");
                    return 1;
                }
            }
            "-v" | "--verbose" => {
                i += 1;
                if i < args.len() {
                    verbose = args[i].clone();
                } else {
                    eprintln!("Error: -v/--verbose requires a level argument (none, v, vv)");
                    return 1;
                }
            }
            "-s" | "--setup" => {
                setup_mode = true;
            }
            "-P" | "--patch" => {
                patch_rom = true;
            }
            "-p" | "--profile" => {
                i += 1;
                if i < args.len() {
                    profile = args[i].clone();
                } else {
                    eprintln!("Error: -p/--profile requires a name argument");
                    return 1;
                }
            }
            _ => {
                eprintln!("Error: Unknown argument: {}", arg);
                print_usage(program_name);
                return 1;
            }
        }
        i += 1;
    }

    // Validate required arguments
    let rootfs = match rootfs {
        Some(p) => p,
        None => {
            eprintln!("Error: -r/--rootfs is required");
            print_usage(program_name);
            return 1;
        }
    };

    // Initialize logger
    let log_level = match verbose.as_str() {
        "none" => "warn",
        "vv" => "debug",
        _ => "info",
    };
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(log_level)).init();

    info!("libtwoyi starting...");
    info!("Rootfs: {:?}", rootfs);

    // Create and start server
    let config = ServerConfig {
        rootfs,
        loader,
        bind_address,
        adb_address,
        width,
        height,
        dpi,
        verbose: verbose != "none",
        setup_mode,
        patch_rom,
        profile,
    };

    let server = TwoyiServer::new(config);
    
    match server.start() {
        Ok(()) => 0,
        Err(e) => {
            error!("Server error: {}", e);
            1
        }
    }
}
