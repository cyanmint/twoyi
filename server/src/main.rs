// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

use clap::Parser;
use log::{info, error, debug, warn};
use std::fs::{self, File};
use std::io::{Write, Read, BufReader, BufRead};
use std::net::{TcpListener, TcpStream};
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::path::PathBuf;

mod input;
mod framebuffer;
mod gralloc;
mod rom_patcher;

/// Default ADB address for scrcpy connections (binds to all interfaces)
/// Note: Server binds to 0.0.0.0 to accept connections from any interface,
/// while app defaults to 127.0.0.1 for localhost connections
const DEFAULT_ADB_ADDRESS: &str = "0.0.0.0:5556";

/// Default binary name for help messages
const DEFAULT_BINARY_NAME: &str = "twoyi-server";

#[derive(Parser, Debug)]
#[command(name = "twoyi-server")]
#[command(about = r#"twoyi container server

This server runs the Android container and exposes the ADB address for scrcpy connections.
The container uses a headless redroid-based ROM that works with scrcpy for display.

Graphics are rendered via scrcpy which connects to the container's ADB daemon.
Use 'scrcpy -s <adb_address>' to connect and view the display.

The server also accepts control connections for configuration and monitoring."#, long_about = None)]
struct Args {
    /// Path to the rootfs directory
    #[arg(short = 'r', long)]
    rootfs: PathBuf,

    /// Path to the loader library (libloader.so)
    #[arg(short = 'l', long)]
    loader: Option<PathBuf>,

    /// Address and port to bind for control connections (e.g., 0.0.0.0:8765)
    #[arg(short = 'b', long, default_value = "0.0.0.0:8765")]
    bind: String,

    /// ADB address and port for scrcpy connections (e.g., 0.0.0.0:5556)
    #[arg(short = 'a', long, default_value = DEFAULT_ADB_ADDRESS)]
    adb_address: String,

    /// Screen width (used by container's display)
    #[arg(short = 'W', long, default_value_t = 1080)]
    width: i32,

    /// Screen height (used by container's display)
    #[arg(short = 'H', long, default_value_t = 1920)]
    height: i32,

    /// Screen DPI (used by container's display)
    #[arg(short = 'd', long, default_value_t = 320)]
    dpi: i32,

    /// Verbose level: "none" (quiet), "v" (default, info), "vv" (extra verbose, debug)
    #[arg(short = 'v', long, default_value = "v")]
    verbose: String,

    /// Setup mode - start server without launching container (for manual environment setup)
    #[arg(short = 's', long)]
    setup: bool,

    /// Patch ROM binaries for custom rootfs path (run once, automatically detects real path)
    #[arg(short = 'P', long)]
    patch: bool,

    /// Profile name for identification (used for managing multiple containers)
    #[arg(short = 'p', long, default_value = "default")]
    profile: String,
}

fn main() {
    let args = Args::parse();

    // Determine verbosity level
    let (log_level, verbose_output) = match args.verbose.as_str() {
        "none" => ("warn", false),
        "vv" => ("debug", true),
        _ => ("info", true), // "v" or default
    };
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(log_level)).init();

    info!("twoyi-server starting...");
    info!("Profile: {}", args.profile);
    info!("Rootfs: {:?}", args.rootfs);
    info!("Control address: {}", args.bind);
    info!("ADB address for scrcpy: {}", args.adb_address);
    info!("Screen size: {}x{} @ {}dpi", args.width, args.height, args.dpi);
    info!("Verbose level: {}", args.verbose);
    if args.setup {
        info!("Setup mode: enabled (container will NOT be started automatically)");
        info!("You can manually set up the environment and start the container later.");
    }
    if args.patch {
        info!("Patch mode: enabled (ROM init binary will be patched for custom paths)");
    }
    info!("Fake gralloc: enabled (capturing graphics from legacy ROMs)");
    if let Some(ref loader) = args.loader {
        info!("Loader: {:?}", loader);
    }

    // Print scrcpy connection info
    info!("=== SCRCPY DISPLAY ===");
    info!("This server uses scrcpy for display via the container's ADB.");
    info!("Connect with: scrcpy -s {}", args.adb_address);
    info!("The container uses a headless redroid-based ROM.");
    info!("======================");

    // Validate rootfs exists
    if !args.rootfs.exists() {
        error!("Rootfs directory does not exist: {:?}", args.rootfs);
        std::process::exit(1);
    }

    // Convert rootfs to absolute path - this is critical!
    // The init process needs absolute paths to work correctly when it re-execs itself.
    let rootfs = match args.rootfs.canonicalize() {
        Ok(p) => p,
        Err(e) => {
            error!("Failed to canonicalize rootfs path {:?}: {}", args.rootfs, e);
            std::process::exit(1);
        }
    };
    info!("Resolved rootfs path: {:?}", rootfs);

    // Also canonicalize loader path if provided
    let loader = args.loader.as_ref().map(|p| {
        if p.exists() {
            match p.canonicalize() {
                Ok(canonical) => canonical,
                Err(e) => {
                    warn!("Failed to canonicalize loader path {:?}: {}, using original path", p, e);
                    p.clone()
                }
            }
        } else {
            warn!("Loader path does not exist: {:?}, using as-is", p);
            p.clone()
        }
    });
    if let Some(ref loader_path) = loader {
        info!("Resolved loader path: {:?}", loader_path);
    }

    let init_path = rootfs.join("init");
    if !init_path.exists() {
        error!("init binary not found at: {:?}", init_path);
        std::process::exit(1);
    }

    let rootfs_str = rootfs.to_string_lossy().to_string();

    // Check if we're using a non-default path without patching
    // This is a common source of "container exits immediately" issues
    // Skip this warning for the default profile
    if !args.patch && !rom_patcher::is_default_path(&rootfs_str) && args.profile != "default" {
        warn!("=== WARNING: Non-default rootfs path without --patch flag ===");
        warn!("Rootfs path '{}' is not the default path.", rootfs_str);
        warn!("The ROM binaries have hardcoded paths that may need patching.");
        warn!("If the container fails to start, try running with --patch flag:");
        warn!("  {} -r {:?} --patch ...", std::env::args().next().unwrap_or(DEFAULT_BINARY_NAME.to_string()), rootfs);
        warn!("============================================================");
    }

    // Patch all ROM binaries for custom rootfs path (only when --patch flag is provided)
    // Skip patching for the default profile
    if args.patch && args.profile != "default" {
        let loader64_str = loader.as_ref().map(|p| p.to_string_lossy().to_string());
        let loader32_str = loader.as_ref().map(|p| {
            // Derive loader32 path from loader64 path (replace "loader64" with "loader32")
            let path_str = p.to_string_lossy().to_string();
            if path_str.ends_with("loader64") {
                path_str.replace("loader64", "loader32")
            } else if path_str.ends_with("64") {
                format!("{}32", &path_str[..path_str.len()-2])
            } else {
                // Fallback: use parent directory + loader32
                p.parent()
                    .map(|parent| parent.join("loader32").to_string_lossy().to_string())
                    .unwrap_or_else(|| path_str.clone())
            }
        });

        info!("=== ROM PATCHING ===");
        match rom_patcher::patch_all_rom_files(
            &rootfs,
            loader64_str.as_deref(),
            loader32_str.as_deref(),
        ) {
            rom_patcher::PatchResult::Success => {
                info!("ROM binaries successfully patched for custom paths");
            }
            rom_patcher::PatchResult::AlreadyPatched => {
                info!("ROM binaries already patched for current paths");
            }
            rom_patcher::PatchResult::DefaultPath => {
                info!("Using default rootfs path, no patching needed");
            }
            rom_patcher::PatchResult::PathTooLong(msg) => {
                error!("Path too long for ROM patching:\n{}", msg);
                error!("Consider using symlinks to create shorter paths.");
                std::process::exit(1);
            }
            rom_patcher::PatchResult::FileNotFound(msg) => {
                error!("ROM patching failed: {}", msg);
                std::process::exit(1);
            }
            rom_patcher::PatchResult::IoError(msg) => {
                error!("ROM patching I/O error: {}", msg);
                std::process::exit(1);
            }
        }
        info!("=========================");
    } else if args.patch && args.profile == "default" {
        info!("Patching skipped for default profile");
    }

    // Start input system
    input::start_input_system(args.width, args.height, &rootfs_str);

    // Set up the rootfs environment (create required directories)
    // This is needed for both normal and setup modes
    setup_rootfs_environment(&rootfs);

    // Start fake gralloc (always enabled)
    let gralloc = Arc::new(gralloc::FakeGralloc::new(&rootfs_str, args.width, args.height));
    gralloc.start();
    info!("Fake gralloc device started - capturing graphics data");

    // Start ADB forwarder (for scrcpy connections)
    let adb_address = args.adb_address.clone();
    let rootfs_for_adb = rootfs.clone();
    thread::spawn(move || {
        start_adb_forwarder(&adb_address, &rootfs_for_adb);
    });

    // Start container process (unless in setup mode)
    let container_running = Arc::new(AtomicBool::new(true));

    if !args.setup {
        let container_running_clone = container_running.clone();
        let rootfs_clone = rootfs.clone();
        let loader_clone = loader.clone();
        let verbose_clone = verbose_output;
        let width = args.width;
        let height = args.height;
        let dpi = args.dpi;
        thread::spawn(move || {
            start_container(&rootfs_clone, loader_clone.as_ref(), verbose_clone, width, height, dpi);
            container_running_clone.store(false, Ordering::SeqCst);
        });
    } else {
        info!("Container startup skipped (setup mode).");
        info!("To start the container manually, run: cd {:?} && ./init", rootfs);
        if let Some(ref loader_path) = loader {
            info!("Don't forget to set: export TYLOADER={:?}", loader_path);
        }
    }

    // Start TCP server for client connections
    let listener = match TcpListener::bind(&args.bind) {
        Ok(l) => l,
        Err(e) => {
            error!("Failed to bind to {}: {}", args.bind, e);
            std::process::exit(1);
        }
    };

    info!("Control server listening on {}", args.bind);

    // Start framebuffer streamer using gralloc shared memory path
    let fb_source = format!("{}/dev/shm/gralloc_fb", rootfs.to_string_lossy());
    let frame_streamer = Arc::new(framebuffer::FrameStreamer::new_with_path(
        args.width,
        args.height,
        &fb_source
    ));
    frame_streamer.start();

    // Keep gralloc instance alive
    let _gralloc = gralloc;

    let setup_mode = args.setup;
    let adb_address_for_clients = args.adb_address.clone();
    let profile_name = args.profile.clone();
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                let width = args.width;
                let height = args.height;
                let rootfs_clone = rootfs.clone();
                let streamer = frame_streamer.clone();
                let adb_addr = adb_address_for_clients.clone();
                let profile = profile_name.clone();
                thread::spawn(move || {
                    handle_client(stream, width, height, &rootfs_clone, setup_mode, streamer, &adb_addr, &profile);
                });
            }
            Err(e) => {
                error!("Error accepting connection: {}", e);
            }
        }
    }
}

/// Set up the rootfs environment for running the container
/// This matches what the Android app does in RomManager.ensureBootFiles()
/// It creates necessary directories that the container and server need
fn setup_rootfs_environment(rootfs: &PathBuf) {
    info!("Setting up rootfs environment in {:?}", rootfs);

    // Create necessary directories (matching RomManager.ensureBootFiles)
    // These are directories where sockets and device files will be created at runtime
    let directories = [
        // Input device directory
        "dev/input",
        // Android socket directory
        "dev/socket",
        // Maps directory
        "dev/maps",
        // Binder directories (for sockets that tar ignored)
        "dev/vbinder",
        "dev/vndbinder",
        "dev/hwbinder",
        // Graphics directory
        "dev/graphics",
        // Shared memory directory
        "dev/shm",
        // Android property system directory (required for init to initialize property area)
        "dev/__properties__",
        // Data system directory
        "data/system",
    ];

    let mut created_count = 0;
    let mut existed_count = 0;

    for dir in &directories {
        let full_path = rootfs.join(dir);
        if full_path.exists() {
            debug!("Directory already exists: {}", dir);
            existed_count += 1;
        } else {
            match fs::create_dir_all(&full_path) {
                Ok(()) => {
                    debug!("Created directory: {}", dir);
                    created_count += 1;
                }
                Err(e) => {
                    warn!("Failed to create directory {:?}: {}", full_path, e);
                }
            }
        }
    }

    info!("Directory setup complete: {} created, {} already existed",
          created_count, existed_count);

    // Note: Input sockets (dev/input/touch, dev/input/key0) are created by
    // start_input_system() when the server starts. Android system sockets
    // (property_service, vold, zygote, etc.) are created by the container's
    // init process when it starts. We just need to ensure the directories exist.
}

/// Start the ADB forwarder for scrcpy connections
/// This listens on the specified address and forwards connections to the container's adbd
fn start_adb_forwarder(adb_address: &str, rootfs: &PathBuf) {
    let listener = match TcpListener::bind(adb_address) {
        Ok(l) => l,
        Err(e) => {
            error!("Failed to bind ADB forwarder to {}: {}", adb_address, e);
            error!("scrcpy connections will not work!");
            return;
        }
    };

    info!("ADB forwarder listening on {}", adb_address);

    // The container's adbd listens on a Unix socket at /dev/socket/adbd
    // We need to forward TCP connections to this socket
    let adbd_socket_path = rootfs.join("dev/socket/adbd");

    for stream in listener.incoming() {
        match stream {
            Ok(client_stream) => {
                let socket_path = adbd_socket_path.clone();
                thread::spawn(move || {
                    forward_adb_connection(client_stream, &socket_path);
                });
            }
            Err(e) => {
                error!("Error accepting ADB connection: {}", e);
            }
        }
    }
}

/// Forward a single ADB connection to the container's adbd socket
fn forward_adb_connection(mut client: TcpStream, adbd_socket_path: &PathBuf) {
    let peer_addr = client.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    debug!("ADB connection from {}", peer_addr);

    // Try to connect to the container's adbd Unix socket
    let mut adbd_socket = match unix_socket::UnixStream::connect(adbd_socket_path) {
        Ok(s) => s,
        Err(e) => {
            debug!("Failed to connect to adbd socket at {:?}: {}", adbd_socket_path, e);
            // If the Unix socket doesn't exist, the container might expose adbd on localhost
            // Try connecting to localhost:5037 (default adb daemon port inside container)
            match TcpStream::connect("127.0.0.1:5037") {
                Ok(s) => {
                    debug!("Connected to adbd via TCP fallback");
                    forward_tcp_streams(client, s);
                    return;
                }
                Err(e2) => {
                    error!("Failed to connect to adbd: socket error: {}, TCP error: {}", e, e2);
                    return;
                }
            }
        }
    };

    // Forward data bidirectionally between client and adbd
    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(e) => {
            error!("Failed to clone client stream: {}", e);
            return;
        }
    };

    let mut adbd_clone = match adbd_socket.try_clone() {
        Ok(a) => a,
        Err(e) => {
            error!("Failed to clone adbd stream: {}", e);
            return;
        }
    };

    // Client -> adbd
    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if adbd_socket.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    // adbd -> Client
    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match adbd_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();

    debug!("ADB connection from {} closed", peer_addr);
}

/// Forward data between two TCP streams bidirectionally
fn forward_tcp_streams(mut client: TcpStream, mut server: TcpStream) {
    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(_) => return,
    };

    let mut server_clone = match server.try_clone() {
        Ok(s) => s,
        Err(_) => return,
    };

    // Client -> Server
    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if server.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    // Server -> Client
    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match server_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();
}

/// Helper function to read from a stream and log lines with a prefix
/// Returns a thread handle that reads from the stream until EOF
fn spawn_stream_reader<R: Read + Send + 'static>(
    mut stream: R,
    prefix: &'static str,
) -> thread::JoinHandle<()> {
    thread::spawn(move || {
        let mut buffer = [0u8; 1024];
        let mut line_buffer = String::new();
        loop {
            match stream.read(&mut buffer) {
                Ok(0) => {
                    // EOF - flush any remaining data
                    if !line_buffer.is_empty() {
                        info!("{} {}", prefix, line_buffer);
                    }
                    break;
                }
                Ok(n) => {
                    // Convert bytes to string and process
                    // Note: This may fail for partial UTF-8 sequences at buffer boundaries
                    if let Ok(text) = std::str::from_utf8(&buffer[..n]) {
                        for ch in text.chars() {
                            if ch == '\n' {
                                info!("{} {}", prefix, line_buffer);
                                line_buffer.clear();
                            } else {
                                line_buffer.push(ch);
                            }
                        }
                    } else {
                        // If UTF-8 conversion fails, try to handle as lossy
                        let text = String::from_utf8_lossy(&buffer[..n]);
                        for ch in text.chars() {
                            if ch == '\n' {
                                info!("{} {}", prefix, line_buffer);
                                line_buffer.clear();
                            } else {
                                line_buffer.push(ch);
                            }
                        }
                    }
                }
                Err(e) => {
                    debug!("Error reading {}: {}", prefix, e);
                    break;
                }
            }
        }
    })
}

fn start_container(rootfs: &PathBuf, loader: Option<&PathBuf>, verbose: bool, width: i32, height: i32, dpi: i32) {
    let working_dir = rootfs.to_string_lossy().to_string();
    let log_path = rootfs.parent()
        .map(|p| p.join("log.txt"))
        .unwrap_or_else(|| PathBuf::from("/tmp/twoyi_log.txt"));

    info!("Starting container in {}", working_dir);
    info!("Container log file: {:?}", log_path);

    // Check if init binary is executable
    let init_path = rootfs.join("init");
    debug!("Init binary path: {:?}", init_path);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&init_path) {
            let mode = metadata.permissions().mode();
            debug!("Init binary permissions: {:o}", mode);
            if mode & 0o111 == 0 {
                warn!("Init binary is not executable! Attempting to fix...");
                if let Err(e) = fs::set_permissions(&init_path, fs::Permissions::from_mode(0o755)) {
                    error!("Failed to make init executable: {}", e);
                }
            }
        }
    }

    let mut cmd = Command::new("./init");
    cmd.current_dir(&working_dir);

    // Set TYLOADER environment variable if loader path is provided
    if let Some(loader_path) = loader {
        let loader_str = loader_path.to_string_lossy().to_string();
        info!("Setting TYLOADER={}", loader_str);
        cmd.env("TYLOADER", loader_str);
    }

    // Set display configuration for redroid-based ROM
    // These are passed as kernel boot parameters style environment variables
    cmd.env("REDROID_WIDTH", width.to_string());
    cmd.env("REDROID_HEIGHT", height.to_string());
    cmd.env("REDROID_DPI", dpi.to_string());

    // Enable ADB over network
    cmd.env("REDROID_ADB_ENABLED", "1");

    // Set fake gralloc environment variables (always enabled)
    info!("Setting up fake gralloc environment");
    for (key, value) in gralloc::get_gralloc_env_vars() {
        cmd.env(key, value);
    }
    // Tell the container where the gralloc shared memory is
    cmd.env("GRALLOC_SHM_PATH", format!("{}/dev/shm/gralloc_fb", working_dir));

    if verbose {
        // In verbose mode, pipe stdout/stderr so we can log them
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::piped());
    } else {
        // In normal mode, redirect to log file
        let outputs = match File::create(&log_path) {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to create log file: {}", e);
                return;
            }
        };
        let errors = match outputs.try_clone() {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to clone log file handle: {}", e);
                return;
            }
        };
        cmd.stdout(Stdio::from(outputs));
        cmd.stderr(Stdio::from(errors));
    }

    let result = cmd.spawn();

    match result {
        Ok(mut child) => {
            info!("Container process started with PID: {:?}", child.id());

            let stdout_handle;
            let stderr_handle;

            if verbose {
                // In verbose mode, read and log stdout/stderr in real-time
                let stdout = child.stdout.take();
                let stderr = child.stderr.take();

                // Spawn threads to read stdout/stderr using the helper function
                stdout_handle = stdout.map(|s| spawn_stream_reader(s, "[container stdout]"));
                stderr_handle = stderr.map(|s| spawn_stream_reader(s, "[container stderr]"));
            } else {
                stdout_handle = None;
                stderr_handle = None;
            }

            match child.wait() {
                Ok(status) => {
                    info!("Container exited with status: {}", status);
                    if let Some(code) = status.code() {
                        if code != 0 {
                            error!("Container exited with error code {}. Common causes:", code);
                            error!("  - Missing root/sudo privileges (try running as root)");
                            error!("  - Missing kernel features (binder, ashmem, etc.)");
                            error!("  - Incorrect loader library path");
                            error!("  - SELinux/AppArmor restrictions");
                        }
                    }
                    #[cfg(unix)]
                    {
                        use std::os::unix::process::ExitStatusExt;
                        if let Some(signal) = status.signal() {
                            error!("Container was killed by signal: {}", signal);
                        }
                    }
                }
                Err(e) => error!("Error waiting for container: {}", e),
            }

            // Wait for reader threads to finish (to capture any remaining output)
            if let Some(handle) = stdout_handle {
                if let Err(e) = handle.join() {
                    warn!("Failed to join stdout reader thread: {:?}", e);
                }
            }
            if let Some(handle) = stderr_handle {
                if let Err(e) = handle.join() {
                    warn!("Failed to join stderr reader thread: {:?}", e);
                }
            }
        }
        Err(e) => {
            error!("Failed to start container: {}", e);
        }
    }
}

fn handle_client(mut stream: TcpStream, width: i32, height: i32, rootfs: &PathBuf, setup_mode: bool, frame_streamer: Arc<framebuffer::FrameStreamer>, adb_address: &str, profile_name: &str) {
    let peer_addr = stream.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    info!("Client connected from {}", peer_addr);

    // Send initial info to client
    let status = if setup_mode { "setup" } else { "running" };
    let info = serde_json::json!({
        "width": width,
        "height": height,
        "rootfs": rootfs.to_string_lossy(),
        "status": status,
        "setup_mode": setup_mode,
        "streaming": true,
        "adb_address": adb_address,
        "display_mode": "fake_gralloc",
        "fake_gralloc": true,
        "profile": profile_name
    });

    if let Ok(info_str) = serde_json::to_string(&info) {
        let _ = stream.write_all(format!("{}\n", info_str).as_bytes());
    }

    // Clone stream for framebuffer streaming (legacy support)
    if let Ok(fb_stream) = stream.try_clone() {
        frame_streamer.add_client(fb_stream);
    }

    // Handle input events from client
    let mut reader = match stream.try_clone() {
        Ok(s) => BufReader::new(s),
        Err(e) => {
            error!("Failed to clone stream for reading: {}", e);
            return;
        }
    };
    let mut line = String::new();

    loop {
        line.clear();
        match reader.read_line(&mut line) {
            Ok(0) => {
                info!("Client {} disconnected", peer_addr);
                break;
            }
            Ok(_) => {
                if let Ok(event) = serde_json::from_str::<serde_json::Value>(&line) {
                    handle_input_event(&event);
                }
            }
            Err(e) => {
                error!("Error reading from client {}: {}", peer_addr, e);
                break;
            }
        }
    }
}

fn handle_input_event(event: &serde_json::Value) {
    if let Some(event_type) = event.get("type").and_then(|v| v.as_str()) {
        match event_type {
            "touch" => {
                let action = event.get("action").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let pointer_id = event.get("pointer_id").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let x = event.get("x").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let y = event.get("y").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let pressure = event.get("pressure").and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;

                input::handle_touch_event(action, pointer_id, x, y, pressure);
            }
            "key" => {
                let keycode = event.get("keycode").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                input::send_key_code(keycode);
            }
            _ => {}
        }
    }
}
