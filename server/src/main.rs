// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! twoyi-server CLI binary
//!
//! This is the standalone executable that can be run from Termux or command line.

#[cfg(feature = "cli")]
use clap::Parser;
use std::path::PathBuf;

use twoyi_server::{ServerConfig, TwoyiServer};

/// Default ADB address for scrcpy connections
const DEFAULT_ADB_ADDRESS: &str = "0.0.0.0:5556";

#[cfg(feature = "cli")]
#[derive(Parser, Debug)]
#[command(name = "twoyi-server")]
#[command(about = r#"twoyi container server

This server runs the Android container and exposes the ADB address for scrcpy connections.
The container uses a headless redroid-based ROM that works with scrcpy for display.

Graphics are rendered via scrcpy which connects to the container's ADB daemon.
Use 'scrcpy -s <adb_address>' to connect and view the display.

The server also accepts control connections for configuration and monitoring."#, long_about = None)]
struct Args {
    /// Path to the rootfs directory
    #[arg(short = 'r', long)]
    rootfs: PathBuf,

    /// Path to the loader library (libloader.so)
    #[arg(short = 'l', long)]
    loader: Option<PathBuf>,

    /// Address and port to bind for control connections (e.g., 0.0.0.0:8765)
    #[arg(short = 'b', long, default_value = "0.0.0.0:8765")]
    bind: String,

    /// ADB address and port for scrcpy connections (e.g., 0.0.0.0:5556)
    #[arg(short = 'a', long, default_value = DEFAULT_ADB_ADDRESS)]
    adb_address: String,

    /// Screen width (used by container's display)
    #[arg(short = 'W', long, default_value_t = 1080)]
    width: i32,

    /// Screen height (used by container's display)
    #[arg(short = 'H', long, default_value_t = 1920)]
    height: i32,

    /// Screen DPI (used by container's display)
    #[arg(short = 'd', long, default_value_t = 320)]
    dpi: i32,

    /// Verbose level: "none" (quiet), "v" (default, info), "vv" (extra verbose, debug)
    #[arg(short = 'v', long, default_value = "v")]
    verbose: String,

    /// Setup mode - start server without launching container (for manual environment setup)
    #[arg(short = 's', long)]
    setup: bool,

    /// Patch ROM binaries for custom rootfs path (run once, automatically detects real path)
    #[arg(short = 'P', long)]
    patch: bool,

    /// Profile name for identification (used for managing multiple containers)
    #[arg(short = 'p', long, default_value = "default")]
    profile: String,
}

#[cfg(feature = "cli")]
fn main() {
    let args = Args::parse();

    // Determine verbosity level
    let log_level = match args.verbose.as_str() {
        "none" => "warn",
        "vv" => "debug",
        _ => "info",
    };
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(log_level)).init();

    let config = ServerConfig {
        rootfs: args.rootfs,
        loader: args.loader,
        bind_address: args.bind,
        adb_address: args.adb_address,
        width: args.width,
        height: args.height,
        dpi: args.dpi,
        verbose: args.verbose != "none",
        setup_mode: args.setup,
        patch_rom: args.patch,
        profile: args.profile,
    };

    let server = TwoyiServer::new(config);
    
    if let Err(e) = server.start() {
        eprintln!("Server error: {}", e);
        std::process::exit(1);
    }
}

#[cfg(not(feature = "cli"))]
fn main() {
    eprintln!("This binary was built without CLI support.");
    eprintln!("Rebuild with: cargo build --features cli");
    std::process::exit(1);
}
