// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! libtwoyi.so - A dual-purpose library that works both as:
//! 1. A JNI library callable from Java/Android
//! 2. A standalone executable server
//!
//! When loaded as a JNI library, it provides native methods for the Android app.
//! When executed directly (./libtwoyi.so), it runs as a standalone server.

use jni::JNIEnv;
use jni::objects::{JClass, JString};
use jni::sys::{jint, jlong, jboolean, JNI_TRUE, JNI_FALSE};
use log::{info, error, debug, warn};
use std::ffi::CString;
use std::path::PathBuf;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

mod input;
mod framebuffer;
mod gralloc;
mod rom_patcher;
mod server;

// Re-export server module for standalone execution
pub use server::run_server;

/// Static flag to track if the server is running
static SERVER_RUNNING: AtomicBool = AtomicBool::new(false);

/// Initialize Android logging
fn init_android_logging() {
    android_logger::init_once(
        android_logger::Config::default()
            .with_max_level(log::LevelFilter::Debug)
            .with_tag("libtwoyi"),
    );
}

// ============================================================================
// JNI Native Methods
// ============================================================================

/// JNI: Initialize the native library
/// Called when the library is loaded via System.loadLibrary("twoyi")
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeInit(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    init_android_logging();
    info!("libtwoyi.so initialized (JNI mode)");
    JNI_TRUE
}

/// JNI: Start the server in the background
/// Returns true if the server started successfully
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeStartServer<'local>(
    mut env: JNIEnv<'local>,
    _class: JClass<'local>,
    rootfs_path: JString<'local>,
    loader_path: JString<'local>,
    bind_address: JString<'local>,
    width: jint,
    height: jint,
    dpi: jint,
) -> jboolean {
    // Check if server is already running
    if SERVER_RUNNING.load(Ordering::SeqCst) {
        warn!("Server is already running");
        return JNI_FALSE;
    }

    // Extract Java strings
    let rootfs: String = match env.get_string(&rootfs_path) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get rootfs path: {:?}", e);
            return JNI_FALSE;
        }
    };

    let loader: Option<String> = if loader_path.is_null() {
        None
    } else {
        match env.get_string(&loader_path) {
            Ok(s) => Some(s.into()),
            Err(_) => None,
        }
    };

    let bind: String = match env.get_string(&bind_address) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get bind address: {:?}", e);
            return JNI_FALSE;
        }
    };

    info!("Starting server via JNI:");
    info!("  rootfs: {}", rootfs);
    info!("  loader: {:?}", loader);
    info!("  bind: {}", bind);
    info!("  size: {}x{} @ {}dpi", width, height, dpi);

    // Start server in a background thread
    SERVER_RUNNING.store(true, Ordering::SeqCst);
    
    thread::spawn(move || {
        let result = server::run_server_with_config(
            &rootfs,
            loader.as_deref(),
            &bind,
            width,
            height,
            dpi,
            false, // setup_mode
            false, // patch_mode
            "default", // profile
        );
        
        if let Err(e) = result {
            error!("Server error: {}", e);
        }
        
        SERVER_RUNNING.store(false, Ordering::SeqCst);
        info!("Server stopped");
    });

    JNI_TRUE
}

/// JNI: Stop the running server
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeStopServer(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    if !SERVER_RUNNING.load(Ordering::SeqCst) {
        warn!("Server is not running");
        return JNI_FALSE;
    }

    info!("Stopping server...");
    // Signal the server to stop (implementation would need a shutdown mechanism)
    // For now, we just mark it as not running
    SERVER_RUNNING.store(false, Ordering::SeqCst);
    
    JNI_TRUE
}

/// JNI: Check if the server is currently running
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeIsServerRunning(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    if SERVER_RUNNING.load(Ordering::SeqCst) {
        JNI_TRUE
    } else {
        JNI_FALSE
    }
}

/// JNI: Send a touch event to the container
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeSendTouch(
    _env: JNIEnv,
    _class: JClass,
    action: jint,
    pointer_id: jint,
    x: jint,
    y: jint,
    pressure: jint,
) {
    input::handle_touch_event(action, pointer_id, x as f32, y as f32, pressure as f32 / 255.0);
}

/// JNI: Send a key event to the container
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeSendKey(
    _env: JNIEnv,
    _class: JClass,
    keycode: jint,
) {
    input::send_key_code(keycode);
}

/// JNI: Get the library version
#[no_mangle]
pub extern "system" fn Java_io_twoyi_Twoyi_nativeGetVersion<'local>(
    env: JNIEnv<'local>,
    _class: JClass<'local>,
) -> JString<'local> {
    let version = env!("CARGO_PKG_VERSION");
    env.new_string(version).unwrap_or_else(|_| env.new_string("unknown").unwrap())
}

// ============================================================================
// Standalone Executable Entry Point
// ============================================================================

/// Main entry point when executed as a standalone binary
/// This uses the _start symbol convention for position-independent executables
#[no_mangle]
pub extern "C" fn main(argc: libc::c_int, argv: *const *const libc::c_char) -> libc::c_int {
    // Initialize standard logging for standalone mode
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    
    info!("libtwoyi.so starting in standalone mode...");
    
    // Parse command line arguments
    let args: Vec<String> = unsafe {
        (0..argc)
            .map(|i| {
                let ptr = *argv.offset(i as isize);
                std::ffi::CStr::from_ptr(ptr)
                    .to_string_lossy()
                    .into_owned()
            })
            .collect()
    };

    // Run the server with command line arguments
    match server::run_server_cli(&args) {
        Ok(()) => 0,
        Err(e) => {
            error!("Server failed: {}", e);
            1
        }
    }
}
