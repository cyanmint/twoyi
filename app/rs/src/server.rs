// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! Core server implementation
//!
//! This module provides the main server logic that can be used from both JNI and CLI.

use log::{info, error, debug, warn};
use std::fs::{self, File};
use std::io::{Write, Read, BufReader, BufRead};
use std::net::{TcpListener, TcpStream};
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::path::PathBuf;
use std::sync::Mutex;

use crate::input;
use crate::framebuffer;
use crate::gralloc;
use crate::rom_patcher;
use crate::renderer_bindings;

/// Default ADB address for scrcpy connections
const DEFAULT_ADB_ADDRESS: &str = "0.0.0.0:5556";

/// Server configuration
#[derive(Clone, Debug)]
pub struct ServerConfig {
    /// Path to the rootfs directory
    pub rootfs: PathBuf,
    /// Path to the loader library (libloader.so)
    pub loader: Option<PathBuf>,
    /// Path to the OpenGL renderer library (libOpenglRender.so)
    pub opengl_lib: Option<PathBuf>,
    /// Address and port to bind for control connections
    pub bind_address: String,
    /// ADB address and port for scrcpy connections
    pub adb_address: String,
    /// Screen width
    pub width: i32,
    /// Screen height
    pub height: i32,
    /// Screen DPI
    pub dpi: i32,
    /// Verbose output
    pub verbose: bool,
    /// Setup mode - don't start container
    pub setup_mode: bool,
    /// Patch ROM binaries
    pub patch_rom: bool,
    /// Profile name
    pub profile: String,
}

impl Default for ServerConfig {
    fn default() -> Self {
        ServerConfig {
            rootfs: PathBuf::from("/data/data/io.twoyi/rootfs"),
            loader: None,
            opengl_lib: None,
            bind_address: "0.0.0.0:8765".to_string(),
            adb_address: DEFAULT_ADB_ADDRESS.to_string(),
            width: 1080,
            height: 1920,
            dpi: 320,
            verbose: false,
            setup_mode: false,
            patch_rom: false,
            profile: "default".to_string(),
        }
    }
}

/// Main server instance
pub struct TwoyiServer {
    config: ServerConfig,
    running: Arc<AtomicBool>,
    container_running: Arc<AtomicBool>,
}

impl TwoyiServer {
    /// Create a new server with the given configuration
    pub fn new(config: ServerConfig) -> Self {
        TwoyiServer {
            config,
            running: Arc::new(AtomicBool::new(false)),
            container_running: Arc::new(AtomicBool::new(false)),
        }
    }

    /// Start the server (blocking)
    pub fn start(&self) -> Result<(), String> {
        if self.running.swap(true, Ordering::SeqCst) {
            return Err("Server already running".to_string());
        }

        info!("twoyi-server starting...");
        info!("Profile: {}", self.config.profile);
        info!("Rootfs: {:?}", self.config.rootfs);
        info!("Control address: {}", self.config.bind_address);
        info!("ADB address for scrcpy: {}", self.config.adb_address);
        info!("Screen size: {}x{} @ {}dpi", self.config.width, self.config.height, self.config.dpi);

        // Validate rootfs exists
        if !self.config.rootfs.exists() {
            return Err(format!("Rootfs directory does not exist: {:?}", self.config.rootfs));
        }

        // Convert rootfs to absolute path
        let rootfs = self.config.rootfs.canonicalize()
            .map_err(|e| format!("Failed to canonicalize rootfs path: {}", e))?;
        info!("Resolved rootfs path: {:?}", rootfs);

        let init_path = rootfs.join("init");
        if !init_path.exists() {
            return Err(format!("init binary not found at: {:?}", init_path));
        }

        let rootfs_str = rootfs.to_string_lossy().to_string();

        // Handle ROM patching if enabled
        if self.config.patch_rom && self.config.profile != "default" {
            self.patch_rom(&rootfs)?;
        }

        // Start input system
        input::start_input_system(self.config.width, self.config.height, &rootfs_str);

        // Set up the rootfs environment
        setup_rootfs_environment(&rootfs);

        // Try to initialize OpenGL renderer for frame capture
        let use_opengl_renderer = init_opengl_renderer_for_server(
            self.config.width,
            self.config.height,
            self.config.dpi,
            self.config.opengl_lib.as_deref()
        );

        // Start fake gralloc (still needed for container communication)
        let gralloc = Arc::new(gralloc::FakeGralloc::new(&rootfs_str, self.config.width, self.config.height));
        gralloc.start();
        info!("Fake gralloc device started");

        // Start ADB forwarder
        let adb_address = self.config.adb_address.clone();
        let rootfs_for_adb = rootfs.clone();
        thread::spawn(move || {
            start_adb_forwarder(&adb_address, &rootfs_for_adb);
        });

        // Start container process (unless in setup mode)
        self.container_running.store(true, Ordering::SeqCst);

        if !self.config.setup_mode {
            let container_running_clone = self.container_running.clone();
            let rootfs_clone = rootfs.clone();
            let loader_clone = self.config.loader.clone();
            let verbose = self.config.verbose;
            let width = self.config.width;
            let height = self.config.height;
            let dpi = self.config.dpi;
            thread::spawn(move || {
                start_container(&rootfs_clone, loader_clone.as_ref(), verbose, width, height, dpi);
                container_running_clone.store(false, Ordering::SeqCst);
            });
        }

        // Start TCP server for client connections
        let listener = TcpListener::bind(&self.config.bind_address)
            .map_err(|e| format!("Failed to bind to {}: {}", self.config.bind_address, e))?;

        info!("Control server listening on {}", self.config.bind_address);

        // Start framebuffer streamer
        let fb_source = format!("{}/dev/shm/gralloc_fb", rootfs.to_string_lossy());
        let frame_streamer = Arc::new(framebuffer::FrameStreamer::new_with_path(
            self.config.width,
            self.config.height,
            &fb_source
        ));
        
        // Enable OpenGL renderer mode if available
        if use_opengl_renderer {
            frame_streamer.set_use_opengl_renderer(true);
        }
        
        frame_streamer.start();

        // Keep gralloc instance alive
        let _gralloc = gralloc;

        let setup_mode = self.config.setup_mode;
        let adb_address_for_clients = self.config.adb_address.clone();
        let profile_name = self.config.profile.clone();
        let width = self.config.width;
        let height = self.config.height;
        
        for stream in listener.incoming() {
            if !self.running.load(Ordering::SeqCst) {
                break;
            }
            
            match stream {
                Ok(stream) => {
                    let rootfs_clone = rootfs.clone();
                    let streamer = frame_streamer.clone();
                    let adb_addr = adb_address_for_clients.clone();
                    let profile = profile_name.clone();
                    let opengl_mode = use_opengl_renderer;
                    thread::spawn(move || {
                        handle_client(stream, width, height, &rootfs_clone, setup_mode, streamer, &adb_addr, &profile, opengl_mode);
                    });
                }
                Err(e) => {
                    error!("Error accepting connection: {}", e);
                }
            }
        }

        Ok(())
    }

    /// Start the server in a background thread
    pub fn start_async(&self) -> Result<thread::JoinHandle<Result<(), String>>, String> {
        let config = self.config.clone();
        let running = self.running.clone();
        let container_running = self.container_running.clone();
        
        Ok(thread::spawn(move || {
            let server = TwoyiServer {
                config,
                running,
                container_running,
            };
            server.start()
        }))
    }

    /// Stop the server
    pub fn stop(&self) {
        self.running.store(false, Ordering::SeqCst);
        info!("Server stopping...");
    }

    /// Check if server is running
    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::SeqCst)
    }

    /// Check if container is running
    pub fn is_container_running(&self) -> bool {
        self.container_running.load(Ordering::SeqCst)
    }

    fn patch_rom(&self, rootfs: &PathBuf) -> Result<(), String> {
        // Derive loader paths
        let loader64_str = self.config.loader.as_ref().map(|p| p.to_string_lossy().to_string());
        let loader32_str = self.config.loader.as_ref().map(|p| {
            let path_str = p.to_string_lossy().to_string();
            if path_str.ends_with("loader64") {
                path_str.replace("loader64", "loader32")
            } else if path_str.ends_with("64") {
                format!("{}32", &path_str[..path_str.len()-2])
            } else {
                p.parent()
                    .map(|parent| parent.join("loader32").to_string_lossy().to_string())
                    .unwrap_or_else(|| path_str.clone())
            }
        });

        info!("=== ROM PATCHING ===");
        match rom_patcher::patch_all_rom_files(
            rootfs,
            loader64_str.as_deref(),
            loader32_str.as_deref(),
        ) {
            rom_patcher::PatchResult::Success => {
                info!("ROM binaries successfully patched");
                Ok(())
            }
            rom_patcher::PatchResult::AlreadyPatched => {
                info!("ROM binaries already patched");
                Ok(())
            }
            rom_patcher::PatchResult::DefaultPath => {
                info!("Using default rootfs path, no patching needed");
                Ok(())
            }
            rom_patcher::PatchResult::PathTooLong(msg) => {
                Err(format!("Path too long: {}", msg))
            }
            rom_patcher::PatchResult::FileNotFound(msg) => {
                Err(format!("File not found: {}", msg))
            }
            rom_patcher::PatchResult::IoError(msg) => {
                Err(format!("IO error: {}", msg))
            }
        }
    }
}

/// OpenGL post callback - called by libOpenglRender.so when a frame is rendered
/// This function captures frames from the OpenGL renderer and stores them in the global buffer
unsafe extern "C" fn opengl_post_callback(
    _context: *mut std::os::raw::c_void,
    _display_id: std::os::raw::c_int,
    width: std::os::raw::c_int,
    height: std::os::raw::c_int,
    _ydir: std::os::raw::c_int,
    _format: std::os::raw::c_int,
    _frame_type: std::os::raw::c_int,
    pixels: *mut u8,
) {
    if pixels.is_null() || width <= 0 || height <= 0 {
        return;
    }
    
    let frame_size = (width * height * 4) as usize; // RGBA format
    let data = std::slice::from_raw_parts(pixels, frame_size);
    
    framebuffer::update_global_frame_buffer(width, height, data);
}

/// Initialize the OpenGL renderer for server mode (headless frame capture)
/// Returns true if the OpenGL renderer was successfully initialized
fn init_opengl_renderer_for_server(width: i32, height: i32, dpi: i32, opengl_lib: Option<&std::path::Path>) -> bool {
    // Set custom library path if provided
    if let Some(path) = opengl_lib {
        if let Some(path_str) = path.to_str() {
            renderer_bindings::set_opengl_lib_path(path_str);
        }
    }
    
    // Try to initialize the renderer library
    if !renderer_bindings::is_renderer_available() {
        info!("OpenGL renderer not available - will use fallback mode");
        return false;
    }
    
    info!("Initializing OpenGL renderer for server mode ({}x{} @ {}dpi)", width, height, dpi);
    
    // Initialize the global frame buffer
    framebuffer::init_global_frame_buffer(width, height);
    
    unsafe {
        // Initialize the headless OpenGL renderer
        let result = renderer_bindings::initOpenGLRenderer(width, height, dpi, dpi, 60);
        if result < 0 {
            warn!("initOpenGLRenderer failed with code: {}", result);
            return false;
        }
        
        // Set up the post callback to capture rendered frames
        renderer_bindings::setPostCallback(opengl_post_callback, std::ptr::null_mut());
    }
    
    info!("OpenGL renderer initialized successfully for frame capture");
    true
}

/// Set up the rootfs environment for running the container
fn setup_rootfs_environment(rootfs: &PathBuf) {
    info!("Setting up rootfs environment in {:?}", rootfs);

    let directories = [
        "dev/input",
        "dev/socket",
        "dev/maps",
        "dev/vbinder",
        "dev/vndbinder",
        "dev/hwbinder",
        "dev/graphics",
        "dev/shm",
        "dev/__properties__",
        "data/system",
    ];

    for dir in &directories {
        let full_path = rootfs.join(dir);
        if !full_path.exists() {
            if let Err(e) = fs::create_dir_all(&full_path) {
                warn!("Failed to create directory {:?}: {}", full_path, e);
            }
        }
    }

    // Create symlinks for opengles sockets
    let default_rootfs = PathBuf::from("/data/data/io.twoyi/rootfs");
    let opengles_sockets = ["opengles", "opengles2", "opengles3"];
    
    for socket_name in &opengles_sockets {
        let profile_socket_path = rootfs.join(socket_name);
        let default_socket_path = default_rootfs.join(socket_name);
        
        if rootfs.as_path() != default_rootfs.as_path() {
            let _ = fs::remove_file(&profile_socket_path);
            if let Err(e) = std::os::unix::fs::symlink(&default_socket_path, &profile_socket_path) {
                warn!("Failed to create symlink {:?} -> {:?}: {}", profile_socket_path, default_socket_path, e);
            }
        }
    }
}

/// Start the ADB forwarder for scrcpy connections
fn start_adb_forwarder(adb_address: &str, rootfs: &PathBuf) {
    let listener = match TcpListener::bind(adb_address) {
        Ok(l) => l,
        Err(e) => {
            error!("Failed to bind ADB forwarder to {}: {}", adb_address, e);
            return;
        }
    };

    info!("ADB forwarder listening on {}", adb_address);
    let adbd_socket_path = rootfs.join("dev/socket/adbd");

    for stream in listener.incoming() {
        match stream {
            Ok(client_stream) => {
                let socket_path = adbd_socket_path.clone();
                thread::spawn(move || {
                    forward_adb_connection(client_stream, &socket_path);
                });
            }
            Err(e) => {
                error!("Error accepting ADB connection: {}", e);
            }
        }
    }
}

fn forward_adb_connection(mut client: TcpStream, adbd_socket_path: &PathBuf) {
    let peer_addr = client.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    debug!("ADB connection from {}", peer_addr);

    let mut adbd_socket = match unix_socket::UnixStream::connect(adbd_socket_path) {
        Ok(s) => s,
        Err(e) => {
            debug!("Failed to connect to adbd socket at {:?}: {}", adbd_socket_path, e);
            match TcpStream::connect("127.0.0.1:5037") {
                Ok(s) => {
                    debug!("Connected to adbd via TCP fallback");
                    forward_tcp_streams(client, s);
                    return;
                }
                Err(e2) => {
                    error!("Failed to connect to adbd: socket error: {}, TCP error: {}", e, e2);
                    return;
                }
            }
        }
    };

    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(e) => {
            error!("Failed to clone client stream: {}", e);
            return;
        }
    };

    let mut adbd_clone = match adbd_socket.try_clone() {
        Ok(a) => a,
        Err(e) => {
            error!("Failed to clone adbd stream: {}", e);
            return;
        }
    };

    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if adbd_socket.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match adbd_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();
    debug!("ADB connection from {} closed", peer_addr);
}

fn forward_tcp_streams(mut client: TcpStream, mut server: TcpStream) {
    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(_) => return,
    };

    let mut server_clone = match server.try_clone() {
        Ok(s) => s,
        Err(_) => return,
    };

    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if server.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match server_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();
}

fn start_container(rootfs: &PathBuf, loader: Option<&PathBuf>, verbose: bool, width: i32, height: i32, dpi: i32) {
    let working_dir = rootfs.to_string_lossy().to_string();
    let log_path = rootfs.parent()
        .map(|p| p.join("log.txt"))
        .unwrap_or_else(|| PathBuf::from("/tmp/twoyi_log.txt"));

    info!("Starting container in {}", working_dir);

    let init_path = rootfs.join("init");
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&init_path) {
            let mode = metadata.permissions().mode();
            if mode & 0o111 == 0 {
                warn!("Init binary is not executable! Attempting to fix...");
                if let Err(e) = fs::set_permissions(&init_path, fs::Permissions::from_mode(0o755)) {
                    error!("Failed to make init executable: {}", e);
                }
            }
        }
    }

    let mut cmd = Command::new("./init");
    cmd.current_dir(&working_dir);

    if let Some(loader_path) = loader {
        let loader_str = loader_path.to_string_lossy().to_string();
        info!("Setting TYLOADER={}", loader_str);
        cmd.env("TYLOADER", loader_str);
    }

    cmd.env("REDROID_WIDTH", width.to_string());
    cmd.env("REDROID_HEIGHT", height.to_string());
    cmd.env("REDROID_DPI", dpi.to_string());
    cmd.env("REDROID_ADB_ENABLED", "1");

    for (key, value) in gralloc::get_gralloc_env_vars() {
        cmd.env(key, value);
    }
    cmd.env("GRALLOC_SHM_PATH", format!("{}/dev/shm/gralloc_fb", working_dir));

    if verbose {
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::piped());
    } else {
        let outputs = match File::create(&log_path) {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to create log file: {}", e);
                return;
            }
        };
        let errors = match outputs.try_clone() {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to clone log file handle: {}", e);
                return;
            }
        };
        cmd.stdout(Stdio::from(outputs));
        cmd.stderr(Stdio::from(errors));
    }

    match cmd.spawn() {
        Ok(mut child) => {
            info!("Container process started with PID: {:?}", child.id());

            if verbose {
                let stdout = child.stdout.take();
                let stderr = child.stderr.take();

                let stdout_handle = stdout.map(|s| spawn_stream_reader(s, "[container stdout]"));
                let stderr_handle = stderr.map(|s| spawn_stream_reader(s, "[container stderr]"));

                match child.wait() {
                    Ok(status) => {
                        info!("Container exited with status: {}", status);
                    }
                    Err(e) => error!("Error waiting for container: {}", e),
                }

                if let Some(handle) = stdout_handle {
                    let _ = handle.join();
                }
                if let Some(handle) = stderr_handle {
                    let _ = handle.join();
                }
            } else {
                match child.wait() {
                    Ok(status) => {
                        info!("Container exited with status: {}", status);
                    }
                    Err(e) => error!("Error waiting for container: {}", e),
                }
            }
        }
        Err(e) => {
            error!("Failed to start container: {}", e);
        }
    }
}

fn spawn_stream_reader<R: Read + Send + 'static>(
    mut stream: R,
    prefix: &'static str,
) -> thread::JoinHandle<()> {
    thread::spawn(move || {
        let mut buffer = [0u8; 1024];
        let mut line_buffer = String::new();
        loop {
            match stream.read(&mut buffer) {
                Ok(0) => {
                    if !line_buffer.is_empty() {
                        info!("{} {}", prefix, line_buffer);
                    }
                    break;
                }
                Ok(n) => {
                    let text = String::from_utf8_lossy(&buffer[..n]);
                    for ch in text.chars() {
                        if ch == '\n' {
                            info!("{} {}", prefix, line_buffer);
                            line_buffer.clear();
                        } else {
                            line_buffer.push(ch);
                        }
                    }
                }
                Err(e) => {
                    debug!("Error reading {}: {}", prefix, e);
                    break;
                }
            }
        }
    })
}

fn handle_client(
    mut stream: TcpStream,
    width: i32,
    height: i32,
    rootfs: &PathBuf,
    setup_mode: bool,
    frame_streamer: Arc<framebuffer::FrameStreamer>,
    adb_address: &str,
    profile_name: &str,
    use_opengl_renderer: bool,
) {
    let peer_addr = stream.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    info!("Client connected from {}", peer_addr);

    let status = if setup_mode { "setup" } else { "running" };
    let display_mode = if use_opengl_renderer { "opengl_renderer" } else { "fake_gralloc" };
    
    let default_rootfs = "/data/data/io.twoyi/rootfs";
    let opengles_path = format!("{}/opengles", default_rootfs);
    let opengles2_path = format!("{}/opengles2", default_rootfs);
    let opengles3_path = format!("{}/opengles3", default_rootfs);
    
    let info = serde_json::json!({
        "width": width,
        "height": height,
        "rootfs": rootfs.to_string_lossy(),
        "status": status,
        "setup_mode": setup_mode,
        "streaming": true,
        "adb_address": adb_address,
        "display_mode": display_mode,
        "opengl_renderer": use_opengl_renderer,
        "fake_gralloc": !use_opengl_renderer,
        "profile": profile_name,
        "sockets": {
            "opengles": opengles_path,
            "opengles2": opengles2_path,
            "opengles3": opengles3_path,
            "touch": format!("{}/dev/input/touch", rootfs.to_string_lossy()),
            "key": format!("{}/dev/input/key0", rootfs.to_string_lossy()),
            "gralloc": format!("{}/dev/graphics/gralloc0", rootfs.to_string_lossy()),
            "gralloc_info": format!("{}/dev/graphics/gralloc_info", rootfs.to_string_lossy()),
            "gralloc_fb": format!("{}/dev/shm/gralloc_fb", rootfs.to_string_lossy())
        }
    });

    if let Ok(info_str) = serde_json::to_string(&info) {
        let _ = stream.write_all(format!("{}\n", info_str).as_bytes());
    }

    if let Ok(fb_stream) = stream.try_clone() {
        frame_streamer.add_client(fb_stream);
    }

    let mut reader = match stream.try_clone() {
        Ok(s) => BufReader::new(s),
        Err(e) => {
            error!("Failed to clone stream for reading: {}", e);
            return;
        }
    };
    let mut line = String::new();

    loop {
        line.clear();
        match reader.read_line(&mut line) {
            Ok(0) => {
                info!("Client {} disconnected", peer_addr);
                break;
            }
            Ok(_) => {
                if let Ok(event) = serde_json::from_str::<serde_json::Value>(&line) {
                    handle_input_event(&event);
                }
            }
            Err(e) => {
                error!("Error reading from client {}: {}", peer_addr, e);
                break;
            }
        }
    }
}

fn handle_input_event(event: &serde_json::Value) {
    if let Some(event_type) = event.get("type").and_then(|v| v.as_str()) {
        match event_type {
            "touch" => {
                let action = event.get("action").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let pointer_id = event.get("pointer_id").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let x = event.get("x").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let y = event.get("y").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let pressure = event.get("pressure").and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;

                input::handle_touch_event(action, pointer_id, x, y, pressure);
            }
            "key" => {
                let keycode = event.get("keycode").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                input::send_key_code(keycode);
            }
            _ => {}
        }
    }
}
