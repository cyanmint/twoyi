// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! Server module - contains the core server functionality for the standalone twoyi-server binary

use clap::Parser;
use log::{info, error, debug, warn};
use std::fs::{self, File};
use std::io::{Write, Read, BufReader, BufRead};
use std::net::{TcpListener, TcpStream};
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::path::PathBuf;

use crate::input;
use crate::framebuffer;
use crate::gralloc;
use crate::rom_patcher;

/// Default ADB address for scrcpy connections (binds to all interfaces)
const DEFAULT_ADB_ADDRESS: &str = "0.0.0.0:5556";

#[derive(Parser, Debug)]
#[command(name = "twoyi-server")]
#[command(about = r#"twoyi container server

This server runs the Android container and exposes the ADB address for scrcpy connections.
The container uses a headless redroid-based ROM that works with scrcpy for display.

Graphics are rendered via scrcpy which connects to the container's ADB daemon.
Use 'scrcpy -s <adb_address>' to connect and view the display.

The server also accepts control connections for configuration and monitoring.

LEGACY MODE (--legacy):
When enabled, uses the original libOpenglRender.so for graphics rendering
instead of the fake gralloc + scrcpy approach. This provides compatibility
with the original twoyi app behavior."#, long_about = None)]
struct Args {
    /// Path to the rootfs directory
    #[arg(short = 'r', long)]
    rootfs: PathBuf,

    /// Path to the loader library (libloader.so)
    #[arg(short = 'l', long)]
    loader: Option<PathBuf>,

    /// Address and port to bind for control connections (e.g., 0.0.0.0:8765)
    #[arg(short = 'b', long, default_value = "0.0.0.0:8765")]
    bind: String,

    /// ADB address and port for scrcpy connections (e.g., 0.0.0.0:5556)
    #[arg(short = 'a', long, default_value = DEFAULT_ADB_ADDRESS)]
    adb_address: String,

    /// Screen width (used by container's display)
    #[arg(short = 'W', long, default_value_t = 1080)]
    width: i32,

    /// Screen height (used by container's display)
    #[arg(short = 'H', long, default_value_t = 1920)]
    height: i32,

    /// Screen DPI (used by container's display)
    #[arg(short = 'd', long, default_value_t = 320)]
    dpi: i32,

    /// Verbose level: "none" (quiet), "v" (default, info), "vv" (extra verbose, debug)
    #[arg(short = 'v', long, default_value = "v")]
    verbose: String,

    /// Setup mode - start server without launching container (for manual environment setup)
    #[arg(short = 's', long)]
    setup: bool,

    /// Patch ROM binaries for custom rootfs path (run once, automatically detects real path)
    #[arg(short = 'P', long)]
    patch: bool,

    /// Profile name for identification (used for managing multiple containers)
    #[arg(short = 'p', long, default_value = "default")]
    profile: String,

    /// Legacy mode - use libOpenglRender.so for graphics instead of fake gralloc + scrcpy.
    /// NOTE: This mode is designed for in-app use only. In standalone server mode,
    /// the container will start but graphics rendering is not available.
    #[arg(short = 'L', long)]
    legacy: bool,

    /// Frames per second for legacy OpenGL renderer (only used with --legacy)
    #[arg(short = 'f', long, default_value_t = 60)]
    fps: i32,
}

/// Run the server with command line arguments (for standalone execution)
pub fn run_server_cli(args: &[String]) -> Result<(), String> {
    let parsed_args = Args::try_parse_from(args)
        .map_err(|e| format!("Failed to parse arguments: {}", e))?;

    run_server_with_args(parsed_args)
}

/// Run the server with parsed arguments
fn run_server_with_args(args: Args) -> Result<(), String> {
    info!("libtwoyi server starting...");
    info!("Profile: {}", args.profile);
    info!("Rootfs: {:?}", args.rootfs);
    info!("Control address: {}", args.bind);
    info!("Screen size: {}x{} @ {}dpi", args.width, args.height, args.dpi);
    info!("Verbose level: {}", args.verbose);
    
    if args.legacy {
        info!("=== LEGACY MODE ===");
        info!("Using OpenGL renderer (libOpenglRender.so) for graphics");
        info!("FPS: {}", args.fps);
        info!("===================");
    } else {
        info!("ADB address for scrcpy: {}", args.adb_address);
        info!("Fake gralloc: enabled (capturing graphics from legacy ROMs)");
        info!("=== SCRCPY DISPLAY ===");
        info!("This server uses scrcpy for display via the container's ADB.");
        info!("Connect with: scrcpy -s {}", args.adb_address);
        info!("======================");
    }
    
    if args.setup {
        info!("Setup mode: enabled (container will NOT be started automatically)");
    }
    if args.patch {
        info!("Patch mode: enabled (ROM init binary will be patched for custom paths)");
    }
    if let Some(ref loader) = args.loader {
        info!("Loader: {:?}", loader);
    }

    // Validate rootfs exists
    if !args.rootfs.exists() {
        return Err(format!("Rootfs directory does not exist: {:?}", args.rootfs));
    }

    // Convert rootfs to absolute path
    let rootfs = args.rootfs.canonicalize()
        .map_err(|e| format!("Failed to canonicalize rootfs path: {}", e))?;
    info!("Resolved rootfs path: {:?}", rootfs);

    // Also canonicalize loader path if provided
    let loader = args.loader.as_ref().map(|p| {
        if p.exists() {
            p.canonicalize().unwrap_or_else(|_| p.clone())
        } else {
            p.clone()
        }
    });

    run_server_internal(
        &rootfs,
        loader.as_ref(),
        &args.bind,
        &args.adb_address,
        args.width,
        args.height,
        args.dpi,
        args.setup,
        args.patch,
        &args.profile,
        args.legacy,
        args.fps,
    )
}

/// Run the server with a configuration (for JNI calls)
pub fn run_server_with_config(
    rootfs: &str,
    loader: Option<&str>,
    bind: &str,
    width: i32,
    height: i32,
    dpi: i32,
    setup_mode: bool,
    patch_mode: bool,
    profile: &str,
) -> Result<(), String> {
    let rootfs_path = PathBuf::from(rootfs);
    let loader_path = loader.map(PathBuf::from);
    let adb_address = DEFAULT_ADB_ADDRESS.to_string();

    run_server_internal(
        &rootfs_path,
        loader_path.as_ref(),
        bind,
        &adb_address,
        width,
        height,
        dpi,
        setup_mode,
        patch_mode,
        profile,
        false, // legacy_mode
        60,    // fps
    )
}

/// Internal server implementation
fn run_server_internal(
    rootfs: &PathBuf,
    loader: Option<&PathBuf>,
    bind: &str,
    adb_address: &str,
    width: i32,
    height: i32,
    dpi: i32,
    setup_mode: bool,
    patch_mode: bool,
    profile: &str,
    legacy_mode: bool,
    _fps: i32, // Currently unused in standalone server mode
) -> Result<(), String> {
    let rootfs_str = rootfs.to_string_lossy().to_string();

    // Check init binary exists
    let init_path = rootfs.join("init");
    if !init_path.exists() {
        return Err(format!("init binary not found at: {:?}", init_path));
    }

    // Check if we're using a non-default path without patching
    if !patch_mode && !rom_patcher::is_default_path(&rootfs_str) && profile != "default" {
        warn!("=== WARNING: Non-default rootfs path without --patch flag ===");
        warn!("Rootfs path '{}' is not the default path.", rootfs_str);
        warn!("The ROM binaries have hardcoded paths that may need patching.");
        warn!("============================================================");
    }

    // Patch ROM binaries if requested
    if patch_mode && profile != "default" {
        let loader64_str = loader.map(|p| p.to_string_lossy().to_string());
        let loader32_str = loader.map(|p| {
            let path_str = p.to_string_lossy().to_string();
            if path_str.ends_with("loader64") {
                path_str.replace("loader64", "loader32")
            } else if path_str.ends_with("64") {
                format!("{}32", &path_str[..path_str.len()-2])
            } else {
                p.parent()
                    .map(|parent| parent.join("loader32").to_string_lossy().to_string())
                    .unwrap_or_else(|| path_str.clone())
            }
        });

        info!("=== ROM PATCHING ===");
        match rom_patcher::patch_all_rom_files(
            rootfs,
            loader64_str.as_deref(),
            loader32_str.as_deref(),
        ) {
            rom_patcher::PatchResult::Success => {
                info!("ROM binaries successfully patched for custom paths");
            }
            rom_patcher::PatchResult::AlreadyPatched => {
                info!("ROM binaries already patched for current paths");
            }
            rom_patcher::PatchResult::DefaultPath => {
                info!("Using default rootfs path, no patching needed");
            }
            rom_patcher::PatchResult::PathTooLong(msg) => {
                return Err(format!("Path too long for ROM patching: {}", msg));
            }
            rom_patcher::PatchResult::FileNotFound(msg) => {
                return Err(format!("ROM patching failed: {}", msg));
            }
            rom_patcher::PatchResult::IoError(msg) => {
                return Err(format!("ROM patching I/O error: {}", msg));
            }
        }
        info!("=========================");
    }

    // Start input system
    input::start_input_system(width, height, &rootfs_str);

    // Set up the rootfs environment
    setup_rootfs_environment(rootfs);

    // Start graphics subsystem based on mode
    let gralloc: Option<Arc<gralloc::FakeGralloc>>;
    
    if legacy_mode {
        // Legacy mode: for standalone server, we can't use libOpenglRender.so
        // because it requires Android's native window system.
        // The container will start but graphics must be accessed via other means.
        warn!("=== LEGACY MODE WARNING ===");
        warn!("Legacy mode is designed for in-app use with libOpenglRender.so.");
        warn!("In standalone server mode, the container will start but the OpenGL renderer");
        warn!("is not available. The container's graphics will not be displayed.");
        warn!("Consider using the normal mode (without -L flag) with scrcpy for display.");
        warn!("===========================");
        gralloc = None;
        
        // Note: We don't start the OpenGL renderer in standalone mode
        // because it requires an Android native window which isn't available.
    } else {
        // Normal mode: use fake gralloc
        let g = Arc::new(gralloc::FakeGralloc::new(&rootfs_str, width, height));
        g.start();
        info!("Fake gralloc device started - capturing graphics data");
        gralloc = Some(g);
    }

    // Start ADB forwarder (only in non-legacy mode)
    if !legacy_mode {
        let adb_address_clone = adb_address.to_string();
        let rootfs_for_adb = rootfs.clone();
        thread::spawn(move || {
            start_adb_forwarder(&adb_address_clone, &rootfs_for_adb);
        });
    }

    // Start container process (unless in setup mode)
    let container_running = Arc::new(AtomicBool::new(true));

    if !setup_mode {
        let container_running_clone = container_running.clone();
        let rootfs_clone = rootfs.clone();
        let loader_clone = loader.cloned();
        let legacy_mode_clone = legacy_mode;
        thread::spawn(move || {
            start_container(&rootfs_clone, loader_clone.as_ref(), true, width, height, dpi, legacy_mode_clone);
            container_running_clone.store(false, Ordering::SeqCst);
        });
    } else {
        info!("Container startup skipped (setup mode).");
        info!("To start the container manually, run: cd {:?} && ./init", rootfs);
    }

    // Start TCP server for client connections
    let listener = TcpListener::bind(bind)
        .map_err(|e| format!("Failed to bind to {}: {}", bind, e))?;

    info!("Control server listening on {}", bind);

    // Start framebuffer streamer (only in non-legacy mode)
    let frame_streamer = if !legacy_mode {
        let fb_source = format!("{}/dev/shm/gralloc_fb", rootfs.to_string_lossy());
        let streamer = Arc::new(framebuffer::FrameStreamer::new_with_path(width, height, &fb_source));
        streamer.start();
        Some(streamer)
    } else {
        None
    };

    // Keep gralloc instance alive
    let _gralloc = gralloc;

    let adb_address_for_clients = adb_address.to_string();
    let profile_name = profile.to_string();
    let legacy_mode_for_client = legacy_mode;
    
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                let rootfs_clone = rootfs.clone();
                let streamer = frame_streamer.clone();
                let adb_addr = adb_address_for_clients.clone();
                let profile = profile_name.clone();
                thread::spawn(move || {
                    handle_client(stream, width, height, &rootfs_clone, setup_mode, streamer, &adb_addr, &profile, legacy_mode_for_client);
                });
            }
            Err(e) => {
                error!("Error accepting connection: {}", e);
            }
        }
    }

    Ok(())
}

/// Set up the rootfs environment for running the container
fn setup_rootfs_environment(rootfs: &PathBuf) {
    info!("Setting up rootfs environment in {:?}", rootfs);

    let directories = [
        "dev/input",
        "dev/socket",
        "dev/maps",
        "dev/vbinder",
        "dev/vndbinder",
        "dev/hwbinder",
        "dev/graphics",
        "dev/shm",
        "dev/__properties__",
        "data/system",
    ];

    let mut created_count = 0;
    let mut existed_count = 0;

    for dir in &directories {
        let full_path = rootfs.join(dir);
        if full_path.exists() {
            debug!("Directory already exists: {}", dir);
            existed_count += 1;
        } else {
            match fs::create_dir_all(&full_path) {
                Ok(()) => {
                    debug!("Created directory: {}", dir);
                    created_count += 1;
                }
                Err(e) => {
                    warn!("Failed to create directory {:?}: {}", full_path, e);
                }
            }
        }
    }

    info!("Directory setup complete: {} created, {} already existed", created_count, existed_count);

    // Create symlinks for opengles sockets
    let default_rootfs = PathBuf::from("/data/data/io.twoyi/rootfs");
    let opengles_sockets = ["opengles", "opengles2", "opengles3"];
    
    for socket_name in &opengles_sockets {
        let profile_socket_path = rootfs.join(socket_name);
        let default_socket_path = default_rootfs.join(socket_name);
        
        if rootfs.as_path() != default_rootfs.as_path() {
            let _ = fs::remove_file(&profile_socket_path);
            match std::os::unix::fs::symlink(&default_socket_path, &profile_socket_path) {
                Ok(()) => {
                    debug!("Created symlink: {:?} -> {:?}", profile_socket_path, default_socket_path);
                }
                Err(e) => {
                    warn!("Failed to create symlink {:?} -> {:?}: {}", profile_socket_path, default_socket_path, e);
                }
            }
        }
    }
}

/// Start the ADB forwarder for scrcpy connections
fn start_adb_forwarder(adb_address: &str, rootfs: &PathBuf) {
    let listener = match TcpListener::bind(adb_address) {
        Ok(l) => l,
        Err(e) => {
            error!("Failed to bind ADB forwarder to {}: {}", adb_address, e);
            return;
        }
    };

    info!("ADB forwarder listening on {}", adb_address);

    let adbd_socket_path = rootfs.join("dev/socket/adbd");

    for stream in listener.incoming() {
        match stream {
            Ok(client_stream) => {
                let socket_path = adbd_socket_path.clone();
                thread::spawn(move || {
                    forward_adb_connection(client_stream, &socket_path);
                });
            }
            Err(e) => {
                error!("Error accepting ADB connection: {}", e);
            }
        }
    }
}

/// Forward a single ADB connection to the container's adbd socket
fn forward_adb_connection(mut client: TcpStream, adbd_socket_path: &PathBuf) {
    let peer_addr = client.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    debug!("ADB connection from {}", peer_addr);

    let mut adbd_socket = match unix_socket::UnixStream::connect(adbd_socket_path) {
        Ok(s) => s,
        Err(e) => {
            debug!("Failed to connect to adbd socket at {:?}: {}", adbd_socket_path, e);
            match TcpStream::connect("127.0.0.1:5037") {
                Ok(s) => {
                    debug!("Connected to adbd via TCP fallback");
                    forward_tcp_streams(client, s);
                    return;
                }
                Err(e2) => {
                    error!("Failed to connect to adbd: socket error: {}, TCP error: {}", e, e2);
                    return;
                }
            }
        }
    };

    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(e) => {
            error!("Failed to clone client stream: {}", e);
            return;
        }
    };

    let mut adbd_clone = match adbd_socket.try_clone() {
        Ok(a) => a,
        Err(e) => {
            error!("Failed to clone adbd stream: {}", e);
            return;
        }
    };

    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if adbd_socket.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match adbd_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();

    debug!("ADB connection from {} closed", peer_addr);
}

/// Forward data between two TCP streams bidirectionally
fn forward_tcp_streams(mut client: TcpStream, mut server: TcpStream) {
    let mut client_clone = match client.try_clone() {
        Ok(c) => c,
        Err(_) => return,
    };

    let mut server_clone = match server.try_clone() {
        Ok(s) => s,
        Err(_) => return,
    };

    let handle1 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match client.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if server.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let handle2 = thread::spawn(move || {
        let mut buf = [0u8; 8192];
        loop {
            match server_clone.read(&mut buf) {
                Ok(0) => break,
                Ok(n) => {
                    if client_clone.write_all(&buf[..n]).is_err() {
                        break;
                    }
                }
                Err(_) => break,
            }
        }
    });

    let _ = handle1.join();
    let _ = handle2.join();
}

fn spawn_stream_reader<R: Read + Send + 'static>(
    mut stream: R,
    prefix: &'static str,
) -> thread::JoinHandle<()> {
    thread::spawn(move || {
        let mut buffer = [0u8; 1024];
        let mut line_buffer = String::new();
        loop {
            match stream.read(&mut buffer) {
                Ok(0) => {
                    if !line_buffer.is_empty() {
                        info!("{} {}", prefix, line_buffer);
                    }
                    break;
                }
                Ok(n) => {
                    if let Ok(text) = std::str::from_utf8(&buffer[..n]) {
                        for ch in text.chars() {
                            if ch == '\n' {
                                info!("{} {}", prefix, line_buffer);
                                line_buffer.clear();
                            } else {
                                line_buffer.push(ch);
                            }
                        }
                    } else {
                        let text = String::from_utf8_lossy(&buffer[..n]);
                        for ch in text.chars() {
                            if ch == '\n' {
                                info!("{} {}", prefix, line_buffer);
                                line_buffer.clear();
                            } else {
                                line_buffer.push(ch);
                            }
                        }
                    }
                }
                Err(e) => {
                    debug!("Error reading {}: {}", prefix, e);
                    break;
                }
            }
        }
    })
}

fn start_container(rootfs: &PathBuf, loader: Option<&PathBuf>, verbose: bool, width: i32, height: i32, dpi: i32, legacy_mode: bool) {
    let working_dir = rootfs.to_string_lossy().to_string();
    let log_path = rootfs.parent()
        .map(|p| p.join("log.txt"))
        .unwrap_or_else(|| PathBuf::from("/tmp/twoyi_log.txt"));

    info!("Starting container in {}", working_dir);
    info!("Container log file: {:?}", log_path);

    let init_path = rootfs.join("init");
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Ok(metadata) = fs::metadata(&init_path) {
            let mode = metadata.permissions().mode();
            if mode & 0o111 == 0 {
                warn!("Init binary is not executable! Attempting to fix...");
                if let Err(e) = fs::set_permissions(&init_path, fs::Permissions::from_mode(0o755)) {
                    error!("Failed to make init executable: {}", e);
                }
            }
        }
    }

    let mut cmd = Command::new("./init");
    cmd.current_dir(&working_dir);

    if let Some(loader_path) = loader {
        let loader_str = loader_path.to_string_lossy().to_string();
        info!("Setting TYLOADER={}", loader_str);
        cmd.env("TYLOADER", loader_str);
    }

    if legacy_mode {
        info!("Legacy mode: using OpenGL renderer environment (minimal env vars)");
        // In legacy mode, only set TYLOADER (already done above) to match original JNI behavior
        // The original JNI code doesn't set any REDROID_* or GRALLOC variables
    } else {
        // Non-legacy mode: set REDROID variables for scrcpy/fake gralloc mode
        cmd.env("REDROID_WIDTH", width.to_string());
        cmd.env("REDROID_HEIGHT", height.to_string());
        cmd.env("REDROID_DPI", dpi.to_string());
        cmd.env("REDROID_ADB_ENABLED", "1");
        
        info!("Setting up fake gralloc environment");
        for (key, value) in gralloc::get_gralloc_env_vars() {
            cmd.env(key, value);
        }
        cmd.env("GRALLOC_SHM_PATH", format!("{}/dev/shm/gralloc_fb", working_dir));
    }

    if verbose {
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::piped());
    } else {
        let outputs = match File::create(&log_path) {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to create log file: {}", e);
                return;
            }
        };
        let errors = match outputs.try_clone() {
            Ok(f) => f,
            Err(e) => {
                error!("Failed to clone log file handle: {}", e);
                return;
            }
        };
        cmd.stdout(Stdio::from(outputs));
        cmd.stderr(Stdio::from(errors));
    }

    let result = cmd.spawn();

    match result {
        Ok(mut child) => {
            info!("Container process started with PID: {:?}", child.id());

            let stdout_handle;
            let stderr_handle;

            if verbose {
                let stdout = child.stdout.take();
                let stderr = child.stderr.take();
                stdout_handle = stdout.map(|s| spawn_stream_reader(s, "[container stdout]"));
                stderr_handle = stderr.map(|s| spawn_stream_reader(s, "[container stderr]"));
            } else {
                stdout_handle = None;
                stderr_handle = None;
            }

            match child.wait() {
                Ok(status) => {
                    info!("Container exited with status: {}", status);
                    if let Some(code) = status.code() {
                        if code != 0 {
                            error!("Container exited with error code {}.", code);
                        }
                    }
                    #[cfg(unix)]
                    {
                        use std::os::unix::process::ExitStatusExt;
                        if let Some(signal) = status.signal() {
                            error!("Container was killed by signal: {}", signal);
                        }
                    }
                }
                Err(e) => error!("Error waiting for container: {}", e),
            }

            if let Some(handle) = stdout_handle {
                let _ = handle.join();
            }
            if let Some(handle) = stderr_handle {
                let _ = handle.join();
            }
        }
        Err(e) => {
            error!("Failed to start container: {}", e);
        }
    }
}

fn handle_client(mut stream: TcpStream, width: i32, height: i32, rootfs: &PathBuf, setup_mode: bool, frame_streamer: Option<Arc<framebuffer::FrameStreamer>>, adb_address: &str, profile_name: &str, legacy_mode: bool) {
    let peer_addr = stream.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string());
    info!("Client connected from {}", peer_addr);

    let status = if setup_mode { "setup" } else { "running" };
    let display_mode = if legacy_mode { "legacy_opengl" } else { "fake_gralloc" };
    
    let default_rootfs = "/data/data/io.twoyi/rootfs";
    let opengles_path = format!("{}/opengles", default_rootfs);
    let opengles2_path = format!("{}/opengles2", default_rootfs);
    let opengles3_path = format!("{}/opengles3", default_rootfs);
    
    let info = serde_json::json!({
        "width": width,
        "height": height,
        "rootfs": rootfs.to_string_lossy(),
        "status": status,
        "setup_mode": setup_mode,
        "streaming": !legacy_mode,
        "adb_address": adb_address,
        "display_mode": display_mode,
        "legacy_mode": legacy_mode,
        "fake_gralloc": !legacy_mode,
        "profile": profile_name,
        "sockets": {
            "opengles": opengles_path,
            "opengles2": opengles2_path,
            "opengles3": opengles3_path,
            "touch": format!("{}/dev/input/touch", rootfs.to_string_lossy()),
            "key": format!("{}/dev/input/key0", rootfs.to_string_lossy()),
            "gralloc": format!("{}/dev/graphics/gralloc0", rootfs.to_string_lossy()),
            "gralloc_info": format!("{}/dev/graphics/gralloc_info", rootfs.to_string_lossy()),
            "gralloc_fb": format!("{}/dev/shm/gralloc_fb", rootfs.to_string_lossy())
        }
    });

    if let Ok(info_str) = serde_json::to_string(&info) {
        let _ = stream.write_all(format!("{}\n", info_str).as_bytes());
    }

    // Only add client to frame streamer in non-legacy mode
    if let Some(ref streamer) = frame_streamer {
        if let Ok(fb_stream) = stream.try_clone() {
            streamer.add_client(fb_stream);
        }
    }

    let mut reader = match stream.try_clone() {
        Ok(s) => BufReader::new(s),
        Err(e) => {
            error!("Failed to clone stream for reading: {}", e);
            return;
        }
    };
    let mut line = String::new();

    loop {
        line.clear();
        match reader.read_line(&mut line) {
            Ok(0) => {
                info!("Client {} disconnected", peer_addr);
                break;
            }
            Ok(_) => {
                if let Ok(event) = serde_json::from_str::<serde_json::Value>(&line) {
                    handle_input_event(&event);
                }
            }
            Err(e) => {
                error!("Error reading from client {}: {}", peer_addr, e);
                break;
            }
        }
    }
}

fn handle_input_event(event: &serde_json::Value) {
    if let Some(event_type) = event.get("type").and_then(|v| v.as_str()) {
        match event_type {
            "touch" => {
                let action = event.get("action").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let pointer_id = event.get("pointer_id").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                let x = event.get("x").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let y = event.get("y").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                let pressure = event.get("pressure").and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;

                input::handle_touch_event(action, pointer_id, x, y, pressure);
            }
            "key" => {
                let keycode = event.get("keycode").and_then(|v| v.as_i64()).unwrap_or(0) as i32;
                input::send_key_code(keycode);
            }
            _ => {}
        }
    }
}
