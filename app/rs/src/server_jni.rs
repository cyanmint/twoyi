// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! JNI bindings for the twoyi server
//!
//! This module provides JNI functions that can be called from Java/Kotlin Android code.

use jni::objects::{JClass, JString};
use jni::sys::{jint, jboolean, JNI_TRUE, JNI_FALSE};
use jni::{JNIEnv, JavaVM, NativeMethod};
use log::{info, error, debug};

use std::ffi::c_void;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

use crate::{ServerConfig, TwoyiServer};
use crate::input as server_input;

/// Global server instance (lazy initialized)
static SERVER: once_cell::sync::Lazy<Mutex<Option<Arc<TwoyiServer>>>> = 
    once_cell::sync::Lazy::new(|| Mutex::new(None));

/// Initialize the server library (call once from Java)
#[no_mangle]
pub extern "C" fn native_server_init(
    _env: JNIEnv,
    _class: JClass,
) {
    info!("twoyi-server JNI library initialized");
}

/// Start the server with the given configuration
/// Returns true on success, false on failure
#[no_mangle]
pub extern "C" fn native_start_server(
    env: JNIEnv,
    _class: JClass,
    rootfs: JString,
    loader: JString,
    bind_address: JString,
    adb_address: JString,
    width: jint,
    height: jint,
    dpi: jint,
    profile: JString,
) -> jboolean {
    let rootfs_str: String = match env.get_string(rootfs) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get rootfs string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let loader_str: Option<String> = if loader.is_null() {
        None
    } else {
        match env.get_string(loader) {
            Ok(s) => Some(s.into()),
            Err(e) => {
                error!("Failed to get loader string: {:?}", e);
                None
            }
        }
    };

    let bind_str: String = match env.get_string(bind_address) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get bind_address string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let adb_str: String = match env.get_string(adb_address) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get adb_address string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let profile_str: String = match env.get_string(profile) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get profile string: {:?}", e);
            return JNI_FALSE;
        }
    };

    let config = ServerConfig {
        rootfs: PathBuf::from(rootfs_str),
        loader: loader_str.map(PathBuf::from),
        bind_address: bind_str,
        adb_address: adb_str,
        width,
        height,
        dpi,
        profile: profile_str,
        ..Default::default()
    };

    let server = Arc::new(TwoyiServer::new(config));
    
    // Store server instance
    {
        let mut guard = match SERVER.lock() {
            Ok(g) => g,
            Err(e) => {
                error!("Mutex poisoned: {:?}", e);
                return JNI_FALSE;
            }
        };
        *guard = Some(server.clone());
    }

    // Start server in background thread
    match server.start_async() {
        Ok(_handle) => {
            info!("Server started successfully");
            JNI_TRUE
        }
        Err(e) => {
            error!("Failed to start server: {}", e);
            JNI_FALSE
        }
    }
}

/// Stop the server
#[no_mangle]
pub extern "C" fn native_stop_server(
    _env: JNIEnv,
    _class: JClass,
) {
    let mut guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        server.stop();
        info!("Server stopped");
    }
    *guard = None;
}

/// Check if server is running
#[no_mangle]
pub extern "C" fn native_is_server_running(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    let guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        if server.is_running() {
            return JNI_TRUE;
        }
    }
    JNI_FALSE
}

/// Check if container is running
#[no_mangle]
pub extern "C" fn native_is_container_running(
    _env: JNIEnv,
    _class: JClass,
) -> jboolean {
    let guard = SERVER.lock().unwrap();
    if let Some(ref server) = *guard {
        if server.is_container_running() {
            return JNI_TRUE;
        }
    }
    JNI_FALSE
}

/// Start only the input system (for use with existing renderer)
#[no_mangle]
pub extern "C" fn native_start_input_system(
    env: JNIEnv,
    _class: JClass,
    rootfs: JString,
    width: jint,
    height: jint,
) {
    let rootfs_str: String = match env.get_string(rootfs) {
        Ok(s) => s.into(),
        Err(e) => {
            error!("Failed to get rootfs string: {:?}", e);
            return;
        }
    };

    info!("Starting input system: {}x{} in {}", width, height, rootfs_str);
    server_input::start_input_system(width, height, &rootfs_str);
}

/// Handle touch event from Java
#[no_mangle]
pub extern "C" fn native_handle_touch_event(
    _env: JNIEnv,
    _class: JClass,
    action: jint,
    pointer_id: jint,
    x: jint,
    y: jint,
    pressure: jint,
) {
    // Clamp coordinates to non-negative values since they represent screen positions
    let x_clamped = if x < 0 { 0 } else { x };
    let y_clamped = if y < 0 { 0 } else { y };
    let pressure_clamped = if pressure < 0 { 0 } else { pressure };
    
    server_input::handle_touch_event(
        action, 
        pointer_id, 
        x_clamped as f32, 
        y_clamped as f32, 
        pressure_clamped as f32
    );
}

/// Send key event from Java
#[no_mangle]
pub extern "C" fn native_send_key_code(
    _env: JNIEnv,
    _class: JClass,
    keycode: jint,
) {
    server_input::send_key_code(keycode);
}

/// Register server JNI methods with the JVM
pub fn register_server_natives(jvm: &JavaVM) {
    let env: JNIEnv = match jvm.get_env() {
        Ok(e) => e,
        Err(e) => {
            error!("Failed to get JNI environment: {:?}", e);
            return;
        }
    };

    let class_name = "io/twoyi/NativeServer";
    let clazz = match env.find_class(class_name) {
        Ok(clazz) => clazz,
        Err(_) => {
            debug!("NativeServer class not found, skipping server JNI registration");
            return;
        }
    };

    let methods = [
        NativeMethod {
            name: "nativeInit".into(),
            sig: "()V".into(),
            fn_ptr: native_server_init as *mut c_void,
        },
        NativeMethod {
            name: "startServer".into(),
            sig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;)Z".into(),
            fn_ptr: native_start_server as *mut c_void,
        },
        NativeMethod {
            name: "stopServer".into(),
            sig: "()V".into(),
            fn_ptr: native_stop_server as *mut c_void,
        },
        NativeMethod {
            name: "isServerRunning".into(),
            sig: "()Z".into(),
            fn_ptr: native_is_server_running as *mut c_void,
        },
        NativeMethod {
            name: "isContainerRunning".into(),
            sig: "()Z".into(),
            fn_ptr: native_is_container_running as *mut c_void,
        },
        NativeMethod {
            name: "startInputSystem".into(),
            sig: "(Ljava/lang/String;II)V".into(),
            fn_ptr: native_start_input_system as *mut c_void,
        },
        NativeMethod {
            name: "handleTouchEvent".into(),
            sig: "(IIIII)V".into(),
            fn_ptr: native_handle_touch_event as *mut c_void,
        },
        NativeMethod {
            name: "sendKeyCode".into(),
            sig: "(I)V".into(),
            fn_ptr: native_send_key_code as *mut c_void,
        },
    ];

    if let Err(e) = env.register_native_methods(clazz, &methods) {
        error!("Failed to register server native methods: {:?}", e);
    } else {
        debug!("Server native methods registered successfully");
    }
}
