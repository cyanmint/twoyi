// This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
// This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).

//! Dynamic bindings to libOpenglRender.so
//!
//! These functions are loaded at runtime via dlopen/dlsym to avoid a hard
//! dependency on libOpenglRender.so. This allows the binary to run in CLI mode
//! (e.g., Termux) without requiring the OpenGL renderer library.

use std::ffi::CString;
use std::os::raw::{c_char, c_int, c_void};
use std::sync::Once;
use log::{error, info};

// Function pointer types
type DestroyOpenGLSubwindowFn = unsafe extern "C" fn() -> c_int;
type RepaintOpenGLDisplayFn = unsafe extern "C" fn();
type SetNativeWindowFn = unsafe extern "C" fn(*mut c_void) -> c_int;
type ResetSubWindowFn = unsafe extern "C" fn(*mut c_void, c_int, c_int, c_int, c_int, c_int, c_int, f32, f32) -> c_int;
type StartOpenGLRendererFn = unsafe extern "C" fn(*mut c_void, c_int, c_int, c_int, c_int, c_int) -> c_int;
type RemoveSubWindowFn = unsafe extern "C" fn(*mut c_void) -> c_int;

// Global storage for function pointers
static mut LIB_HANDLE: *mut c_void = std::ptr::null_mut();
static mut FN_DESTROY_OPENGL_SUBWINDOW: Option<DestroyOpenGLSubwindowFn> = None;
static mut FN_REPAINT_OPENGL_DISPLAY: Option<RepaintOpenGLDisplayFn> = None;
static mut FN_SET_NATIVE_WINDOW: Option<SetNativeWindowFn> = None;
static mut FN_RESET_SUBWINDOW: Option<ResetSubWindowFn> = None;
static mut FN_START_OPENGL_RENDERER: Option<StartOpenGLRendererFn> = None;
static mut FN_REMOVE_SUBWINDOW: Option<RemoveSubWindowFn> = None;

static INIT: Once = Once::new();

extern "C" {
    fn dlopen(filename: *const c_char, flags: c_int) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlerror() -> *const c_char;
}

const RTLD_NOW: c_int = 2;

/// Initialize the OpenGL renderer library bindings
/// Returns true if the library was loaded successfully, false otherwise
pub fn init_renderer() -> bool {
    let mut success = false;
    INIT.call_once(|| {
        unsafe {
            // Try to load libOpenglRender.so
            let lib_name = CString::new("libOpenglRender.so").unwrap();
            LIB_HANDLE = dlopen(lib_name.as_ptr(), RTLD_NOW);
            
            if LIB_HANDLE.is_null() {
                let err = dlerror();
                if !err.is_null() {
                    let err_str = std::ffi::CStr::from_ptr(err).to_string_lossy();
                    info!("libOpenglRender.so not available: {} (this is OK for CLI mode)", err_str);
                }
                return;
            }
            
            info!("libOpenglRender.so loaded successfully");
            
            // Load function pointers
            macro_rules! load_fn {
                ($name:expr, $type:ty, $ptr:ident) => {{
                    let name = CString::new($name).unwrap();
                    let ptr = dlsym(LIB_HANDLE, name.as_ptr());
                    if !ptr.is_null() {
                        $ptr = Some(std::mem::transmute::<*mut c_void, $type>(ptr));
                    } else {
                        error!("Failed to load symbol: {}", $name);
                    }
                }};
            }
            
            load_fn!("destroyOpenGLSubwindow", DestroyOpenGLSubwindowFn, FN_DESTROY_OPENGL_SUBWINDOW);
            load_fn!("repaintOpenGLDisplay", RepaintOpenGLDisplayFn, FN_REPAINT_OPENGL_DISPLAY);
            load_fn!("setNativeWindow", SetNativeWindowFn, FN_SET_NATIVE_WINDOW);
            load_fn!("resetSubWindow", ResetSubWindowFn, FN_RESET_SUBWINDOW);
            load_fn!("startOpenGLRenderer", StartOpenGLRendererFn, FN_START_OPENGL_RENDERER);
            load_fn!("removeSubWindow", RemoveSubWindowFn, FN_REMOVE_SUBWINDOW);
            
            success = true;
        }
    });
    
    // After Once::call_once, check if we have a valid handle
    unsafe { !LIB_HANDLE.is_null() || success }
}

/// Check if the renderer library is available
pub fn is_renderer_available() -> bool {
    init_renderer();
    unsafe { !LIB_HANDLE.is_null() }
}

#[allow(dead_code)]
pub unsafe fn destroyOpenGLSubwindow() -> c_int {
    if let Some(f) = FN_DESTROY_OPENGL_SUBWINDOW {
        f()
    } else {
        error!("destroyOpenGLSubwindow not available");
        -1
    }
}

#[allow(dead_code)]
pub unsafe fn repaintOpenGLDisplay() {
    if let Some(f) = FN_REPAINT_OPENGL_DISPLAY {
        f()
    } else {
        error!("repaintOpenGLDisplay not available");
    }
}

#[allow(dead_code)]
pub unsafe fn setNativeWindow(window: *mut c_void) -> c_int {
    if let Some(f) = FN_SET_NATIVE_WINDOW {
        f(window)
    } else {
        error!("setNativeWindow not available");
        -1
    }
}

#[allow(dead_code)]
pub unsafe fn resetSubWindow(
    p_window: *mut c_void,
    wx: c_int,
    wy: c_int,
    ww: c_int,
    wh: c_int,
    fbw: c_int,
    fbh: c_int,
    dpr: f32,
    z_rot: f32,
) -> c_int {
    if let Some(f) = FN_RESET_SUBWINDOW {
        f(p_window, wx, wy, ww, wh, fbw, fbh, dpr, z_rot)
    } else {
        error!("resetSubWindow not available");
        -1
    }
}

#[allow(dead_code)]
pub unsafe fn startOpenGLRenderer(
    win: *mut c_void,
    width: c_int,
    height: c_int,
    xdpi: c_int,
    ydpi: c_int,
    fps: c_int,
) -> c_int {
    if let Some(f) = FN_START_OPENGL_RENDERER {
        f(win, width, height, xdpi, ydpi, fps)
    } else {
        error!("startOpenGLRenderer not available");
        -1
    }
}

#[allow(dead_code)]
pub unsafe fn removeSubWindow(window: *mut c_void) -> c_int {
    if let Some(f) = FN_REMOVE_SUBWINDOW {
        f(window)
    } else {
        error!("removeSubWindow not available");
        -1
    }
}
