/*
 * This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
 * This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).
 */

package io.twoyi.utils;

import android.content.Context;
import android.util.Log;

import io.twoyi.NativeServer;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages the twoyi server via JNI (libtwoyi.so)
 * 
 * The server runs in-process using JNI calls to libtwoyi.so,
 * which works both as a JNI library and as a standalone executable.
 */
public class ServerManager {
    private static final String TAG = "ServerManager";

    private static boolean serverRunning = false;
    private static final List<ServerOutputListener> outputListeners = new ArrayList<>();
    private static final List<String> serverLog = new ArrayList<>();
    private static final int MAX_LOG_LINES = 500;

    /**
     * Interface for receiving server output
     */
    public interface ServerOutputListener {
        void onServerOutput(String line);
    }

    /**
     * Add a listener for server output
     */
    public static void addOutputListener(ServerOutputListener listener) {
        synchronized (outputListeners) {
            if (!outputListeners.contains(listener)) {
                outputListeners.add(listener);
            }
        }
    }

    /**
     * Remove a listener for server output
     */
    public static void removeOutputListener(ServerOutputListener listener) {
        synchronized (outputListeners) {
            outputListeners.remove(listener);
        }
    }

    /**
     * Get the current server log
     */
    public static List<String> getServerLog() {
        synchronized (serverLog) {
            return new ArrayList<>(serverLog);
        }
    }

    /**
     * Clear the server log
     */
    public static void clearServerLog() {
        synchronized (serverLog) {
            serverLog.clear();
        }
    }

    private static void notifyOutputListeners(String line) {
        List<ServerOutputListener> listenersCopy;
        synchronized (serverLog) {
            serverLog.add(line);
            while (serverLog.size() > MAX_LOG_LINES) {
                serverLog.remove(0);
            }
            synchronized (outputListeners) {
                listenersCopy = new ArrayList<>(outputListeners);
            }
        }
        for (ServerOutputListener listener : listenersCopy) {
            try {
                listener.onServerOutput(line);
            } catch (Exception e) {
                Log.e(TAG, "Error notifying listener", e);
            }
        }
    }

    /**
     * Start the local server with the given rootfs path and bind address
     */
    public static void startServer(Context context, String bindAddress, int width, int height) throws IOException {
        // Get active profile
        Profile activeProfile = ProfileManager.getInstance(context).getActiveProfile();
        startServer(context, bindAddress, width, height, activeProfile);
    }

    /**
     * Start the local server with a specific profile configuration
     */
    public static void startServer(Context context, String bindAddress, int width, int height, Profile profile) throws IOException {
        // Stop any existing server
        stopServer();
        
        // Clear previous log
        clearServerLog();

        // Check if native library is available
        if (!NativeServer.isLibraryLoaded()) {
            throw new IOException("Native library libtwoyi.so not loaded");
        }
        
        // Get rootfs path from profile or default
        ProfileManager profileManager = ProfileManager.getInstance(context);
        File rootfsDir = profile != null ? 
                profileManager.getRootfsDir(profile) : 
                RomManager.getRootfsDir(context);
        if (!rootfsDir.exists()) {
            throw new IOException("Rootfs directory does not exist: " + rootfsDir);
        }

        // Get loader path (may be null)
        String loaderPath = RomManager.getLoaderPath(context);

        // Ensure boot files exist in the profile-specific rootfs directory
        RomManager.ensureBootFiles(context, rootfsDir);

        // Get profile name and DPI
        String profileName = profile != null ? profile.getName() : "default";
        int dpi = profile != null ? profile.getDpi() : 320;

        // Parse bind address
        String adbAddress = "0.0.0.0:5556";

        notifyOutputListeners("Starting server via JNI...");
        notifyOutputListeners("Rootfs: " + rootfsDir.getAbsolutePath());
        notifyOutputListeners("Bind address: " + bindAddress);
        notifyOutputListeners("Screen: " + width + "x" + height + " @ " + dpi + "dpi");
        notifyOutputListeners("Profile: " + profileName);

        // Start server via JNI
        boolean success = NativeServer.startServer(
                rootfsDir.getAbsolutePath(),
                loaderPath,  // Can be null
                bindAddress,
                adbAddress,
                width,
                height,
                dpi,
                profileName
        );

        if (success) {
            serverRunning = true;
            Log.i(TAG, "Server started via JNI");
            notifyOutputListeners("Server started successfully");
        } else {
            throw new IOException("Failed to start native server");
        }
    }

    /**
     * Stop the running server
     */
    public static void stopServer() {
        if (serverRunning) {
            NativeServer.stopServer();
            serverRunning = false;
            Log.i(TAG, "Server stopped");
            notifyOutputListeners("Server stopped");
        }
    }

    /**
     * Check if the server is running
     */
    public static boolean isServerRunning() {
        return serverRunning && NativeServer.isServerRunning();
    }

    /**
     * Test connection to a server at the given address
     */
    public static boolean testConnection(String address) {
        String[] parts = address.split(":");
        if (parts.length != 2) {
            return false;
        }
        
        String host = parts[0];
        int port;
        try {
            port = Integer.parseInt(parts[1]);
        } catch (NumberFormatException e) {
            return false;
        }
        
        try (Socket socket = new Socket(host, port);
             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
            socket.setSoTimeout(5000);
            String response = reader.readLine();
            return response != null && response.contains("status");
        } catch (IOException e) {
            Log.e(TAG, "Connection test failed", e);
            return false;
        }
    }

    /**
     * Send a touch event to the server
     */
    public static void sendTouchEvent(PrintWriter writer, int action, int pointerId, float x, float y, float pressure) {
        String event = String.format(
            "{\"type\":\"touch\",\"action\":%d,\"pointer_id\":%d,\"x\":%.1f,\"y\":%.1f,\"pressure\":%.1f}\n",
            action, pointerId, x, y, pressure
        );
        writer.print(event);
        writer.flush();
    }

    /**
     * Send a key event to the server
     */
    public static void sendKeyEvent(PrintWriter writer, int keycode) {
        String event = String.format("{\"type\":\"key\",\"keycode\":%d}\n", keycode);
        writer.print(event);
        writer.flush();
    }
}
