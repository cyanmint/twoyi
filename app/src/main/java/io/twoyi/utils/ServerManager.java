/*
 * This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
 * This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).
 */

package io.twoyi.utils;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages the twoyi server as a standalone process.
 * 
 * This class spawns libtwoyi.so as a subprocess for "local server mode".
 * This is different from "legacy local mode" which uses JNI via the Renderer class.
 * 
 * libtwoyi.so is a PIE (Position Independent Executable) that works both as:
 * - A JNI library when loaded by Android app (via System.loadLibrary)
 * - An executable when run directly: ./libtwoyi.so -r $(realpath rootfs)
 */
public class ServerManager {
    private static final String TAG = "ServerManager";
    private static final String LIBTWOYI_NAME = "libtwoyi.so";

    private static Process serverProcess = null;
    private static Thread outputReaderThread = null;
    private static final List<ServerOutputListener> outputListeners = new ArrayList<>();
    private static final List<String> serverLog = new ArrayList<>();
    private static final int MAX_LOG_LINES = 500;

    /**
     * Interface for receiving server output
     */
    public interface ServerOutputListener {
        void onServerOutput(String line);
    }

    /**
     * Add a listener for server output
     */
    public static void addOutputListener(ServerOutputListener listener) {
        synchronized (outputListeners) {
            if (!outputListeners.contains(listener)) {
                outputListeners.add(listener);
            }
        }
    }

    /**
     * Remove a listener for server output
     */
    public static void removeOutputListener(ServerOutputListener listener) {
        synchronized (outputListeners) {
            outputListeners.remove(listener);
        }
    }

    /**
     * Get the current server log
     */
    public static List<String> getServerLog() {
        synchronized (serverLog) {
            return new ArrayList<>(serverLog);
        }
    }

    /**
     * Clear the server log
     */
    public static void clearServerLog() {
        synchronized (serverLog) {
            serverLog.clear();
        }
    }

    private static void notifyOutputListeners(String line) {
        List<ServerOutputListener> listenersCopy;
        synchronized (serverLog) {
            serverLog.add(line);
            while (serverLog.size() > MAX_LOG_LINES) {
                serverLog.remove(0);
            }
            synchronized (outputListeners) {
                listenersCopy = new ArrayList<>(outputListeners);
            }
        }
        for (ServerOutputListener listener : listenersCopy) {
            try {
                listener.onServerOutput(line);
            } catch (Exception e) {
                Log.e(TAG, "Error notifying listener", e);
            }
        }
    }

    /**
     * Get the path to libtwoyi.so
     */
    private static String getLibtwoyiPath(Context context) {
        ApplicationInfo applicationInfo = context.getApplicationInfo();
        return new File(applicationInfo.nativeLibraryDir, LIBTWOYI_NAME).getAbsolutePath();
    }

    /**
     * Start the local server with the given rootfs path and bind address
     */
    public static void startServer(Context context, String bindAddress, int width, int height) throws IOException {
        // Get active profile
        Profile activeProfile = ProfileManager.getInstance(context).getActiveProfile();
        startServer(context, bindAddress, width, height, activeProfile);
    }

    /**
     * Start the local server with a specific profile configuration.
     * This spawns libtwoyi.so as a subprocess (local server mode).
     */
    public static void startServer(Context context, String bindAddress, int width, int height, Profile profile) throws IOException {
        // Stop any existing server
        stopServer();
        
        // Clear previous log
        clearServerLog();

        // Get libtwoyi.so path
        String libtwoyiPath = getLibtwoyiPath(context);
        File libtwoyiFile = new File(libtwoyiPath);
        if (!libtwoyiFile.exists()) {
            throw new IOException("libtwoyi.so not found at: " + libtwoyiPath);
        }
        
        // Get rootfs path from profile or default
        ProfileManager profileManager = ProfileManager.getInstance(context);
        File rootfsDir = profile != null ? 
                profileManager.getRootfsDir(profile) : 
                RomManager.getRootfsDir(context);
        if (!rootfsDir.exists()) {
            throw new IOException("Rootfs directory does not exist: " + rootfsDir);
        }

        // Get loader path (may be null)
        String loaderPath = RomManager.getLoaderPath(context);

        // Ensure boot files exist in the profile-specific rootfs directory
        RomManager.ensureBootFiles(context, rootfsDir);

        // Get profile name and DPI
        String profileName = profile != null ? profile.getName() : "default";
        int dpi = profile != null ? profile.getDpi() : 320;

        notifyOutputListeners("Server process starting...");
        notifyOutputListeners("Executable: " + libtwoyiPath);
        notifyOutputListeners("Rootfs: " + rootfsDir.getAbsolutePath());
        notifyOutputListeners("Bind address: " + bindAddress);
        notifyOutputListeners("Screen: " + width + "x" + height + " @ " + dpi + "dpi");
        notifyOutputListeners("Profile: " + profileName);

        // Build command arguments for libtwoyi.so
        List<String> command = new ArrayList<>();
        command.add(libtwoyiPath);
        command.add("-r");
        command.add(rootfsDir.getAbsolutePath());
        command.add("-b");
        command.add(bindAddress);
        command.add("-W");
        command.add(String.valueOf(width));
        command.add("-H");
        command.add(String.valueOf(height));
        command.add("-d");
        command.add(String.valueOf(dpi));
        command.add("-p");
        command.add(profileName);
        
        // Add loader if available
        if (loaderPath != null && new File(loaderPath).exists()) {
            command.add("-l");
            command.add(loaderPath);
        }

        Log.i(TAG, "Starting server with command: " + String.join(" ", command));
        notifyOutputListeners("Command: " + String.join(" ", command));

        try {
            ProcessBuilder pb = new ProcessBuilder(command);
            pb.redirectErrorStream(true);
            pb.directory(rootfsDir);
            
            // Set LD_LIBRARY_PATH to find any dependent libraries
            pb.environment().put("LD_LIBRARY_PATH", 
                    context.getApplicationInfo().nativeLibraryDir + ":" + 
                    System.getenv("LD_LIBRARY_PATH"));
            
            serverProcess = pb.start();
            notifyOutputListeners("Server process started");

            // Start thread to read output
            outputReaderThread = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(serverProcess.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        final String outputLine = line;
                        Log.d(TAG, "Server: " + outputLine);
                        notifyOutputListeners(outputLine);
                    }
                } catch (IOException e) {
                    Log.e(TAG, "Error reading server output", e);
                }
                
                // Check exit code when process ends
                try {
                    int exitCode = serverProcess.waitFor();
                    Log.i(TAG, "Server process exited with code: " + exitCode);
                    notifyOutputListeners("Server process exited with code: " + exitCode);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "ServerOutputReader");
            outputReaderThread.start();

            Log.i(TAG, "Server started as subprocess");
        } catch (IOException e) {
            Log.e(TAG, "Failed to start server process", e);
            throw new IOException("Failed to start server process: " + e.getMessage(), e);
        }
    }

    /**
     * Stop the running server
     */
    public static void stopServer() {
        if (serverProcess != null) {
            serverProcess.destroy();
            serverProcess = null;
            Log.i(TAG, "Server stopped");
            notifyOutputListeners("Server stopped");
        }
        
        if (outputReaderThread != null) {
            outputReaderThread.interrupt();
            outputReaderThread = null;
        }
    }

    /**
     * Check if the server is running
     */
    public static boolean isServerRunning() {
        return serverProcess != null && serverProcess.isAlive();
    }

    /**
     * Test connection to a server at the given address
     */
    public static boolean testConnection(String address) {
        String[] parts = address.split(":");
        if (parts.length != 2) {
            return false;
        }
        
        String host = parts[0];
        int port;
        try {
            port = Integer.parseInt(parts[1]);
        } catch (NumberFormatException e) {
            return false;
        }
        
        try (Socket socket = new Socket(host, port);
             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
            socket.setSoTimeout(5000);
            String response = reader.readLine();
            return response != null && response.contains("status");
        } catch (IOException e) {
            Log.e(TAG, "Connection test failed", e);
            return false;
        }
    }

    /**
     * Send a touch event to the server
     */
    public static void sendTouchEvent(PrintWriter writer, int action, int pointerId, float x, float y, float pressure) {
        String event = String.format(
            "{\"type\":\"touch\",\"action\":%d,\"pointer_id\":%d,\"x\":%.1f,\"y\":%.1f,\"pressure\":%.1f}\n",
            action, pointerId, x, y, pressure
        );
        writer.print(event);
        writer.flush();
    }

    /**
     * Send a key event to the server
     */
    public static void sendKeyEvent(PrintWriter writer, int keycode) {
        String event = String.format("{\"type\":\"key\",\"keycode\":%d}\n", keycode);
        writer.print(event);
        writer.flush();
    }
}
