/*
 * This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
 * This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).
 */

package io.twoyi.utils;

import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Utility class for patching the ROM's init binary to work with custom paths.
 * 
 * The ROM's init binary has hardcoded paths that need to be patched for custom rootfs locations:
 *   - /data/data/io.twoyi/rootfs   (26 bytes)
 *   - /data/data/io.twoyi/loader64 (28 bytes)
 *   - /data/data/io.twoyi/loader32 (28 bytes)
 * 
 * Additionally, derived paths in other ROM binaries:
 *   - /data/data/io.twoyi/rootfs/dev/socket/property_service (54 bytes)
 *   - /data/data/io.twoyi/rootfs/opengles (35 bytes)
 *   - /data/data/io.twoyi/rootfs/opengles2 (36 bytes)
 *   - /data/data/io.twoyi/rootfs/opengles3 (36 bytes)
 *   - /data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv1_CM_emulation.so (69 bytes)
 *   - /data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv2_emulation.so (66 bytes)
 * 
 * This class provides methods to patch these paths to point to custom locations.
 */
public class RomPatcher {

    private static final String TAG = "RomPatcher";

    // Original hardcoded paths in the ROM binaries
    public static final String ORIG_ROOTFS = "/data/data/io.twoyi/rootfs";
    public static final String ORIG_LOADER64 = "/data/data/io.twoyi/loader64";
    public static final String ORIG_LOADER32 = "/data/data/io.twoyi/loader32";

    // Derived paths (start with ORIG_ROOTFS)
    public static final String ORIG_PROPERTY_SERVICE = "/data/data/io.twoyi/rootfs/dev/socket/property_service";
    public static final String ORIG_OPENGLES = "/data/data/io.twoyi/rootfs/opengles";
    public static final String ORIG_OPENGLES2 = "/data/data/io.twoyi/rootfs/opengles2";
    public static final String ORIG_OPENGLES3 = "/data/data/io.twoyi/rootfs/opengles3";
    public static final String ORIG_GLES1_EMU = "/data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv1_CM_emulation.so";
    public static final String ORIG_GLES2_EMU = "/data/data/io.twoyi/rootfs/vendor/lib64/egl/libGLESv2_emulation.so";

    // Maximum path lengths (must match original paths)
    public static final int MAX_ROOTFS_LEN = ORIG_ROOTFS.length();   // 26
    public static final int MAX_LOADER64_LEN = ORIG_LOADER64.length(); // 28
    public static final int MAX_LOADER32_LEN = ORIG_LOADER32.length(); // 28

    // Files that need patching (relative to rootfs directory)
    public static final String[] FILES_TO_PATCH = {
        "init",
        "sbin/charger",
        "system/lib64/libc.so",
        "system/lib64/libOpenglRender.so",
        "system/lib64/libui.so",
        "system/bin/adbd",
        "system/bin/linker64",
        "system/bin/mdnsd",
        "system/vendor/lib64/egl/libEGL_emulation.so",
        "system/vendor/lib64/libOpenglSystemCommon.so",
        "system/xbin/su",
    };

    /**
     * Check if the given rootfs directory is the default path that doesn't need patching.
     * 
     * @param rootfsDir The rootfs directory to check
     * @return true if this is the default path (no patching needed)
     */
    public static boolean isDefaultPath(File rootfsDir) {
        String path = rootfsDir.getAbsolutePath();
        return ORIG_ROOTFS.equals(path);
    }

    /**
     * Check if the init binary needs to be patched for the given rootfs path.
     * 
     * @param initFile The init binary file
     * @param rootfsPath The target rootfs path
     * @return true if patching is needed
     * @throws IOException if the file cannot be read
     */
    public static boolean needsPatching(File initFile, String rootfsPath) throws IOException {
        if (!initFile.exists()) {
            return false;
        }

        // If the rootfs path matches the original, no patching needed
        if (ORIG_ROOTFS.equals(rootfsPath)) {
            return false;
        }

        // Check if the binary contains the original path (hasn't been patched yet)
        byte[] content = readFile(initFile);
        byte[] searchBytes = ORIG_ROOTFS.getBytes(StandardCharsets.UTF_8);
        return containsBytes(content, searchBytes);
    }

    /**
     * Check if the init binary has been patched for the given rootfs path.
     * 
     * @param initFile The init binary file
     * @param rootfsPath The target rootfs path
     * @return true if already patched for this path
     * @throws IOException if the file cannot be read
     */
    public static boolean isPatched(File initFile, String rootfsPath) throws IOException {
        if (!initFile.exists()) {
            return false;
        }

        byte[] content = readFile(initFile);
        byte[] searchBytes = rootfsPath.getBytes(StandardCharsets.UTF_8);
        return containsBytes(content, searchBytes);
    }

    /**
     * Validate that the paths are within the allowed length limits.
     * 
     * @param rootfsPath The rootfs path
     * @param loader64Path The loader64 path
     * @param loader32Path The loader32 path
     * @return null if valid, or an error message if invalid
     */
    public static String validatePathLengths(String rootfsPath, String loader64Path, String loader32Path) {
        StringBuilder errors = new StringBuilder();

        if (rootfsPath.length() > MAX_ROOTFS_LEN) {
            errors.append(String.format("Rootfs path too long: %d chars (max: %d)\n",
                    rootfsPath.length(), MAX_ROOTFS_LEN));
        }
        if (loader64Path.length() > MAX_LOADER64_LEN) {
            errors.append(String.format("Loader64 path too long: %d chars (max: %d)\n",
                    loader64Path.length(), MAX_LOADER64_LEN));
        }
        if (loader32Path.length() > MAX_LOADER32_LEN) {
            errors.append(String.format("Loader32 path too long: %d chars (max: %d)\n",
                    loader32Path.length(), MAX_LOADER32_LEN));
        }

        return errors.length() > 0 ? errors.toString().trim() : null;
    }

    /**
     * Patch the init binary to use custom paths.
     * 
     * @param initFile The init binary file to patch
     * @param rootfsPath The new rootfs path
     * @param loader64Path The new loader64 path
     * @param loader32Path The new loader32 path
     * @return true if patching succeeded
     * @throws IOException if file operations fail
     * @throws IllegalArgumentException if paths are too long
     */
    public static boolean patchInitBinary(File initFile, String rootfsPath, 
            String loader64Path, String loader32Path) throws IOException {
        
        // Validate path lengths
        String validationError = validatePathLengths(rootfsPath, loader64Path, loader32Path);
        if (validationError != null) {
            throw new IllegalArgumentException(validationError);
        }

        if (!initFile.exists()) {
            Log.e(TAG, "Init file does not exist: " + initFile.getAbsolutePath());
            return false;
        }

        // Create backup
        File backupFile = new File(initFile.getAbsolutePath() + ".backup");
        if (!backupFile.exists()) {
            copyFile(initFile, backupFile);
            Log.i(TAG, "Created backup: " + backupFile.getAbsolutePath());
        }

        // Read the init binary once
        byte[] content = readFile(initFile);
        byte[] originalContent = content.clone();
        Log.i(TAG, "Read init binary: " + content.length + " bytes");

        // Perform replacements
        boolean modified = false;

        byte[] tempContent = replaceBytes(content, ORIG_ROOTFS, rootfsPath, MAX_ROOTFS_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
            Log.i(TAG, "Patched rootfs path: " + rootfsPath);
        } else {
            Log.w(TAG, "Rootfs path not found or already patched");
        }

        tempContent = replaceBytes(content, ORIG_LOADER64, loader64Path, MAX_LOADER64_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
            Log.i(TAG, "Patched loader64 path: " + loader64Path);
        } else {
            Log.w(TAG, "Loader64 path not found or already patched");
        }

        tempContent = replaceBytes(content, ORIG_LOADER32, loader32Path, MAX_LOADER32_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
            Log.i(TAG, "Patched loader32 path: " + loader32Path);
        } else {
            Log.w(TAG, "Loader32 path not found or already patched");
        }

        if (modified) {
            // Write the patched binary
            writeFile(initFile, content);
            Log.i(TAG, "Wrote patched init binary");

            // Ensure it's executable
            initFile.setExecutable(true, false);
        }

        return modified;
    }

    /**
     * Patch the init binary using default loader paths derived from the rootfs path.
     * 
     * @param initFile The init binary file to patch
     * @param rootfsPath The new rootfs path
     * @return true if patching succeeded
     * @throws IOException if file operations fail
     * @throws IllegalArgumentException if loader paths cannot be derived
     */
    public static boolean patchInitBinary(File initFile, String rootfsPath) throws IOException {
        // Derive loader paths from rootfs path
        File rootfsDir = new File(rootfsPath);
        File parentDir = rootfsDir.getParentFile();
        
        String loader64Path;
        String loader32Path;
        
        if (parentDir != null) {
            loader64Path = new File(parentDir, "loader64").getAbsolutePath();
            loader32Path = new File(parentDir, "loader32").getAbsolutePath();
        } else {
            // This should not happen for valid absolute paths
            throw new IllegalArgumentException(
                "Cannot derive loader paths: rootfs path has no parent directory: " + rootfsPath);
        }

        return patchInitBinary(initFile, rootfsPath, loader64Path, loader32Path);
    }

    /**
     * Restore the init binary from backup.
     * 
     * @param initFile The init binary file
     * @return true if restoration succeeded
     * @throws IOException if file operations fail
     */
    public static boolean restoreFromBackup(File initFile) throws IOException {
        File backupFile = new File(initFile.getAbsolutePath() + ".backup");
        if (!backupFile.exists()) {
            Log.e(TAG, "Backup file does not exist: " + backupFile.getAbsolutePath());
            return false;
        }

        copyFile(backupFile, initFile);
        initFile.setExecutable(true, false);
        Log.i(TAG, "Restored init from backup");
        return true;
    }

    // Helper method to read a file into a byte array
    private static byte[] readFile(File file) throws IOException {
        try (FileInputStream fis = new FileInputStream(file)) {
            byte[] content = new byte[(int) file.length()];
            int offset = 0;
            int remaining = content.length;
            while (remaining > 0) {
                int bytesRead = fis.read(content, offset, remaining);
                if (bytesRead == -1) {
                    throw new IOException("Unexpected end of file: read " + offset + " of " + content.length + " bytes");
                }
                offset += bytesRead;
                remaining -= bytesRead;
            }
            return content;
        }
    }

    // Helper method to write a byte array to a file
    private static void writeFile(File file, byte[] content) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(content);
        }
    }

    // Helper method to copy a file
    private static void copyFile(File src, File dst) throws IOException {
        byte[] content = readFile(src);
        writeFile(dst, content);
    }

    // Check if a byte array contains a sequence
    private static boolean containsBytes(byte[] haystack, byte[] needle) {
        for (int i = 0; i <= haystack.length - needle.length; i++) {
            boolean found = true;
            for (int j = 0; j < needle.length; j++) {
                if (haystack[i + j] != needle[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                return true;
            }
        }
        return false;
    }

    // Find all occurrences of a byte sequence in a byte array
    private static List<Integer> findAllOccurrences(byte[] haystack, byte[] needle) {
        List<Integer> positions = new ArrayList<>();
        for (int i = 0; i <= haystack.length - needle.length; i++) {
            boolean found = true;
            for (int j = 0; j < needle.length; j++) {
                if (haystack[i + j] != needle[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                positions.add(i);
            }
        }
        return positions;
    }

    // Replace a string with another string (padded with null bytes) in a byte array
    // Returns null if oldStr was not found
    private static byte[] replaceBytes(byte[] content, String oldStr, String newStr, int targetLen) {
        byte[] oldBytes = oldStr.getBytes(StandardCharsets.UTF_8);
        
        // Create padded new bytes (new string + null padding)
        byte[] newBytes = new byte[targetLen];
        byte[] newStrBytes = newStr.getBytes(StandardCharsets.UTF_8);
        System.arraycopy(newStrBytes, 0, newBytes, 0, newStrBytes.length);
        // Rest is already zeros (null padding)

        // Find all occurrences
        List<Integer> positions = findAllOccurrences(content, oldBytes);
        if (positions.isEmpty()) {
            return null;
        }

        // Create result array and copy with replacements
        byte[] result = Arrays.copyOf(content, content.length);
        for (int pos : positions) {
            System.arraycopy(newBytes, 0, result, pos, targetLen);
        }

        return result;
    }

    /**
     * Get the recommended short path format for a given rootfs location.
     * If the path is too long, suggests using symlinks.
     * 
     * @param rootfsPath The original rootfs path
     * @return A recommendation string or null if path is short enough
     */
    public static String getShortPathRecommendation(String rootfsPath) {
        if (rootfsPath.length() <= MAX_ROOTFS_LEN) {
            return null;
        }

        // Suggest a short symlink path
        return String.format(
            "Path '%s' is too long (%d chars, max %d).\n" +
            "Create a symlink: ln -s '%s' /data/ty1\n" +
            "Then use /data/ty1 as the rootfs path.",
            rootfsPath, rootfsPath.length(), MAX_ROOTFS_LEN, rootfsPath
        );
    }

    /**
     * Patch a single binary file with all known hardcoded paths.
     * 
     * @param file The binary file to patch
     * @param rootfsPath The new rootfs path
     * @param loader64Path The new loader64 path
     * @param loader32Path The new loader32 path
     * @return true if the file was modified
     * @throws IOException if file operations fail
     */
    private static boolean patchSingleFile(File file, String rootfsPath, 
            String loader64Path, String loader32Path) throws IOException {
        if (!file.exists()) {
            Log.d(TAG, "File not found, skipping: " + file.getAbsolutePath());
            return false;
        }

        byte[] content = readFile(file);
        byte[] originalContent = content.clone();
        boolean modified = false;

        // Patch base paths
        byte[] tempContent = replaceBytes(content, ORIG_ROOTFS, rootfsPath, MAX_ROOTFS_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
        }

        tempContent = replaceBytes(content, ORIG_LOADER64, loader64Path, MAX_LOADER64_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
        }

        tempContent = replaceBytes(content, ORIG_LOADER32, loader32Path, MAX_LOADER32_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
        }

        // Patch derived paths
        String[][] derivedPaths = {
            {ORIG_PROPERTY_SERVICE, rootfsPath + "/dev/socket/property_service"},
            {ORIG_OPENGLES, rootfsPath + "/opengles"},
            {ORIG_OPENGLES2, rootfsPath + "/opengles2"},
            {ORIG_OPENGLES3, rootfsPath + "/opengles3"},
            {ORIG_GLES1_EMU, rootfsPath + "/vendor/lib64/egl/libGLESv1_CM_emulation.so"},
            {ORIG_GLES2_EMU, rootfsPath + "/vendor/lib64/egl/libGLESv2_emulation.so"},
        };

        for (String[] pathPair : derivedPaths) {
            String origPath = pathPair[0];
            String newPath = pathPair[1];
            int origLen = origPath.length();
            if (newPath.length() <= origLen) {
                tempContent = replaceBytes(content, origPath, newPath, origLen);
                if (tempContent != null) {
                    content = tempContent;
                    modified = true;
                }
            } else {
                Log.d(TAG, "Derived path " + newPath + " is too long (" + 
                      newPath.length() + " > " + origLen + "), skipping");
            }
        }

        if (modified) {
            // Create backup
            File backupFile = new File(file.getAbsolutePath() + ".backup");
            if (!backupFile.exists()) {
                copyFile(file, backupFile);
            }

            writeFile(file, content);
            file.setExecutable(true, false);
            Log.d(TAG, "Patched file: " + file.getAbsolutePath());
        }

        return modified;
    }

    /**
     * Patch all ROM files that contain hardcoded paths.
     * 
     * @param rootfsDir The rootfs directory
     * @return number of files patched
     * @throws IOException if file operations fail
     * @throws IllegalArgumentException if paths are too long
     */
    public static int patchAllRomFiles(File rootfsDir) throws IOException {
        String rootfsPath = rootfsDir.getAbsolutePath();
        
        // Derive loader paths from rootfs path
        File parentDir = rootfsDir.getParentFile();
        String loader64Path;
        String loader32Path;
        
        if (parentDir != null) {
            loader64Path = new File(parentDir, "loader64").getAbsolutePath();
            loader32Path = new File(parentDir, "loader32").getAbsolutePath();
        } else {
            throw new IllegalArgumentException(
                "Cannot derive loader paths: rootfs path has no parent directory: " + rootfsPath);
        }

        return patchAllRomFiles(rootfsDir, loader64Path, loader32Path);
    }

    /**
     * Patch all ROM files that contain hardcoded paths.
     * 
     * @param rootfsDir The rootfs directory
     * @param loader64Path The new loader64 path
     * @param loader32Path The new loader32 path
     * @return number of files patched
     * @throws IOException if file operations fail
     * @throws IllegalArgumentException if paths are too long
     */
    public static int patchAllRomFiles(File rootfsDir, String loader64Path, String loader32Path) 
            throws IOException {
        String rootfsPath = rootfsDir.getAbsolutePath();

        // Validate path lengths
        String validationError = validatePathLengths(rootfsPath, loader64Path, loader32Path);
        if (validationError != null) {
            throw new IllegalArgumentException(validationError);
        }

        Log.i(TAG, "Patching ROM files in " + rootfsDir.getAbsolutePath());
        Log.i(TAG, "New rootfs path: " + rootfsPath);
        Log.i(TAG, "New loader64 path: " + loader64Path);
        Log.i(TAG, "New loader32 path: " + loader32Path);

        int totalPatched = 0;
        int totalErrors = 0;

        for (String relativePath : FILES_TO_PATCH) {
            File file = new File(rootfsDir, relativePath);
            try {
                if (patchSingleFile(file, rootfsPath, loader64Path, loader32Path)) {
                    Log.i(TAG, "Patched: " + relativePath);
                    totalPatched++;
                } else {
                    Log.d(TAG, "Skipped (not found or no changes): " + relativePath);
                }
            } catch (IOException e) {
                Log.w(TAG, "Error patching " + relativePath + ": " + e.getMessage());
                totalErrors++;
            }
        }

        Log.i(TAG, "ROM patching complete: " + totalPatched + " files patched, " + totalErrors + " errors");
        return totalPatched;
    }
}
