/*
 * This file was generated by AI (GitHub Copilot) and is NOT APPLICABLE for copyright.
 * This is part of the threetwi project, a fork of twoyi (https://github.com/twoyi/twoyi).
 */

package io.twoyi.utils;

import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Utility class for patching the ROM's init binary to work with custom paths.
 * 
 * The ROM's init binary has hardcoded paths that need to be patched for custom rootfs locations:
 *   - /data/data/io.twoyi/rootfs   (26 bytes)
 *   - /data/data/io.twoyi/loader64 (28 bytes)
 *   - /data/data/io.twoyi/loader32 (28 bytes)
 * 
 * This class provides methods to patch these paths to point to custom locations.
 */
public class RomPatcher {

    private static final String TAG = "RomPatcher";

    // Original hardcoded paths in the init binary
    public static final String ORIG_ROOTFS = "/data/data/io.twoyi/rootfs";
    public static final String ORIG_LOADER64 = "/data/data/io.twoyi/loader64";
    public static final String ORIG_LOADER32 = "/data/data/io.twoyi/loader32";

    // Maximum path lengths (must match original paths)
    public static final int MAX_ROOTFS_LEN = ORIG_ROOTFS.length();   // 26
    public static final int MAX_LOADER64_LEN = ORIG_LOADER64.length(); // 28
    public static final int MAX_LOADER32_LEN = ORIG_LOADER32.length(); // 28

    /**
     * Check if the given rootfs directory is the default path that doesn't need patching.
     * 
     * @param rootfsDir The rootfs directory to check
     * @return true if this is the default path (no patching needed)
     */
    public static boolean isDefaultPath(File rootfsDir) {
        String path = rootfsDir.getAbsolutePath();
        return ORIG_ROOTFS.equals(path);
    }

    /**
     * Check if the init binary needs to be patched for the given rootfs path.
     * 
     * @param initFile The init binary file
     * @param rootfsPath The target rootfs path
     * @return true if patching is needed
     * @throws IOException if the file cannot be read
     */
    public static boolean needsPatching(File initFile, String rootfsPath) throws IOException {
        if (!initFile.exists()) {
            return false;
        }

        // If the rootfs path matches the original, no patching needed
        if (ORIG_ROOTFS.equals(rootfsPath)) {
            return false;
        }

        // Check if the binary contains the original path (hasn't been patched yet)
        byte[] content = readFile(initFile);
        byte[] searchBytes = ORIG_ROOTFS.getBytes(StandardCharsets.UTF_8);
        return containsBytes(content, searchBytes);
    }

    /**
     * Check if the init binary has been patched for the given rootfs path.
     * 
     * @param initFile The init binary file
     * @param rootfsPath The target rootfs path
     * @return true if already patched for this path
     * @throws IOException if the file cannot be read
     */
    public static boolean isPatched(File initFile, String rootfsPath) throws IOException {
        if (!initFile.exists()) {
            return false;
        }

        byte[] content = readFile(initFile);
        byte[] searchBytes = rootfsPath.getBytes(StandardCharsets.UTF_8);
        return containsBytes(content, searchBytes);
    }

    /**
     * Validate that the paths are within the allowed length limits.
     * 
     * @param rootfsPath The rootfs path
     * @param loader64Path The loader64 path
     * @param loader32Path The loader32 path
     * @return null if valid, or an error message if invalid
     */
    public static String validatePathLengths(String rootfsPath, String loader64Path, String loader32Path) {
        StringBuilder errors = new StringBuilder();

        if (rootfsPath.length() > MAX_ROOTFS_LEN) {
            errors.append(String.format("Rootfs path too long: %d chars (max: %d)\n",
                    rootfsPath.length(), MAX_ROOTFS_LEN));
        }
        if (loader64Path.length() > MAX_LOADER64_LEN) {
            errors.append(String.format("Loader64 path too long: %d chars (max: %d)\n",
                    loader64Path.length(), MAX_LOADER64_LEN));
        }
        if (loader32Path.length() > MAX_LOADER32_LEN) {
            errors.append(String.format("Loader32 path too long: %d chars (max: %d)\n",
                    loader32Path.length(), MAX_LOADER32_LEN));
        }

        return errors.length() > 0 ? errors.toString().trim() : null;
    }

    /**
     * Patch the init binary to use custom paths.
     * 
     * @param initFile The init binary file to patch
     * @param rootfsPath The new rootfs path
     * @param loader64Path The new loader64 path
     * @param loader32Path The new loader32 path
     * @return true if patching succeeded
     * @throws IOException if file operations fail
     * @throws IllegalArgumentException if paths are too long
     */
    public static boolean patchInitBinary(File initFile, String rootfsPath, 
            String loader64Path, String loader32Path) throws IOException {
        
        // Validate path lengths
        String validationError = validatePathLengths(rootfsPath, loader64Path, loader32Path);
        if (validationError != null) {
            throw new IllegalArgumentException(validationError);
        }

        if (!initFile.exists()) {
            Log.e(TAG, "Init file does not exist: " + initFile.getAbsolutePath());
            return false;
        }

        // Create backup
        File backupFile = new File(initFile.getAbsolutePath() + ".backup");
        if (!backupFile.exists()) {
            copyFile(initFile, backupFile);
            Log.i(TAG, "Created backup: " + backupFile.getAbsolutePath());
        }

        // Read the init binary
        byte[] content = readFile(initFile);
        Log.i(TAG, "Read init binary: " + content.length + " bytes");

        // Perform replacements
        boolean modified = false;

        content = replaceBytes(content, ORIG_ROOTFS, rootfsPath, MAX_ROOTFS_LEN);
        if (content != null) {
            modified = true;
            Log.i(TAG, "Patched rootfs path: " + rootfsPath);
        } else {
            content = readFile(initFile);
            Log.w(TAG, "Rootfs path not found or already patched");
        }

        byte[] tempContent = replaceBytes(content, ORIG_LOADER64, loader64Path, MAX_LOADER64_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
            Log.i(TAG, "Patched loader64 path: " + loader64Path);
        } else {
            Log.w(TAG, "Loader64 path not found or already patched");
        }

        tempContent = replaceBytes(content, ORIG_LOADER32, loader32Path, MAX_LOADER32_LEN);
        if (tempContent != null) {
            content = tempContent;
            modified = true;
            Log.i(TAG, "Patched loader32 path: " + loader32Path);
        } else {
            Log.w(TAG, "Loader32 path not found or already patched");
        }

        if (modified) {
            // Write the patched binary
            writeFile(initFile, content);
            Log.i(TAG, "Wrote patched init binary");

            // Ensure it's executable
            initFile.setExecutable(true, false);
        }

        return modified;
    }

    /**
     * Patch the init binary using default loader paths derived from the rootfs path.
     * 
     * @param initFile The init binary file to patch
     * @param rootfsPath The new rootfs path
     * @return true if patching succeeded
     * @throws IOException if file operations fail
     */
    public static boolean patchInitBinary(File initFile, String rootfsPath) throws IOException {
        // Derive loader paths from rootfs path
        File rootfsDir = new File(rootfsPath);
        File parentDir = rootfsDir.getParentFile();
        
        String loader64Path;
        String loader32Path;
        
        if (parentDir != null) {
            loader64Path = new File(parentDir, "loader64").getAbsolutePath();
            loader32Path = new File(parentDir, "loader32").getAbsolutePath();
        } else {
            // Fallback - shouldn't happen in practice
            loader64Path = rootfsPath.replace("/rootfs", "/loader64");
            loader32Path = rootfsPath.replace("/rootfs", "/loader32");
        }

        return patchInitBinary(initFile, rootfsPath, loader64Path, loader32Path);
    }

    /**
     * Restore the init binary from backup.
     * 
     * @param initFile The init binary file
     * @return true if restoration succeeded
     * @throws IOException if file operations fail
     */
    public static boolean restoreFromBackup(File initFile) throws IOException {
        File backupFile = new File(initFile.getAbsolutePath() + ".backup");
        if (!backupFile.exists()) {
            Log.e(TAG, "Backup file does not exist: " + backupFile.getAbsolutePath());
            return false;
        }

        copyFile(backupFile, initFile);
        initFile.setExecutable(true, false);
        Log.i(TAG, "Restored init from backup");
        return true;
    }

    // Helper method to read a file into a byte array
    private static byte[] readFile(File file) throws IOException {
        try (FileInputStream fis = new FileInputStream(file)) {
            byte[] content = new byte[(int) file.length()];
            int bytesRead = fis.read(content);
            if (bytesRead != content.length) {
                throw new IOException("Could not read entire file");
            }
            return content;
        }
    }

    // Helper method to write a byte array to a file
    private static void writeFile(File file, byte[] content) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(content);
        }
    }

    // Helper method to copy a file
    private static void copyFile(File src, File dst) throws IOException {
        byte[] content = readFile(src);
        writeFile(dst, content);
    }

    // Check if a byte array contains a sequence
    private static boolean containsBytes(byte[] haystack, byte[] needle) {
        for (int i = 0; i <= haystack.length - needle.length; i++) {
            boolean found = true;
            for (int j = 0; j < needle.length; j++) {
                if (haystack[i + j] != needle[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                return true;
            }
        }
        return false;
    }

    // Find all occurrences of a byte sequence in a byte array
    private static List<Integer> findAllOccurrences(byte[] haystack, byte[] needle) {
        List<Integer> positions = new ArrayList<>();
        for (int i = 0; i <= haystack.length - needle.length; i++) {
            boolean found = true;
            for (int j = 0; j < needle.length; j++) {
                if (haystack[i + j] != needle[j]) {
                    found = false;
                    break;
                }
            }
            if (found) {
                positions.add(i);
            }
        }
        return positions;
    }

    // Replace a string with another string (padded with null bytes) in a byte array
    // Returns null if oldStr was not found
    private static byte[] replaceBytes(byte[] content, String oldStr, String newStr, int targetLen) {
        byte[] oldBytes = oldStr.getBytes(StandardCharsets.UTF_8);
        
        // Create padded new bytes (new string + null padding)
        byte[] newBytes = new byte[targetLen];
        byte[] newStrBytes = newStr.getBytes(StandardCharsets.UTF_8);
        System.arraycopy(newStrBytes, 0, newBytes, 0, newStrBytes.length);
        // Rest is already zeros (null padding)

        // Find all occurrences
        List<Integer> positions = findAllOccurrences(content, oldBytes);
        if (positions.isEmpty()) {
            return null;
        }

        // Create result array and copy with replacements
        byte[] result = Arrays.copyOf(content, content.length);
        for (int pos : positions) {
            System.arraycopy(newBytes, 0, result, pos, targetLen);
        }

        return result;
    }

    /**
     * Get the recommended short path format for a given rootfs location.
     * If the path is too long, suggests using symlinks.
     * 
     * @param rootfsPath The original rootfs path
     * @return A recommendation string or null if path is short enough
     */
    public static String getShortPathRecommendation(String rootfsPath) {
        if (rootfsPath.length() <= MAX_ROOTFS_LEN) {
            return null;
        }

        // Suggest a short symlink path
        return String.format(
            "Path '%s' is too long (%d chars, max %d).\n" +
            "Create a symlink: ln -s '%s' /data/ty1\n" +
            "Then use /data/ty1 as the rootfs path.",
            rootfsPath, rootfsPath.length(), MAX_ROOTFS_LEN, rootfsPath
        );
    }
}
